// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: core/Tron.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// MARK: - _GeneratedWithProtocGenSwiftVersion

/// If the compiler emits an error on this type, it is because this file
/// was generated by a version of the `protoc` Swift plug-in that is
/// incompatible with the version of SwiftProtobuf to which you are linking.
/// Please ensure that you are building against the same version of the API
/// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 { }
    typealias Version = _2
}

// MARK: - Protocol_AccountType

enum Protocol_AccountType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case normal // = 0
    case assetIssue // = 1
    case contract // = 2
    case UNRECOGNIZED(Int)

    init() {
        self = .normal
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .normal
        case 1: self = .assetIssue
        case 2: self = .contract
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .normal: 0
        case .assetIssue: 1
        case .contract: 2
        case .UNRECOGNIZED(let i): i
        }
    }
}

#if swift(>=4.2)

extension Protocol_AccountType: CaseIterable {
    /// The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Protocol_AccountType] = [
        .normal,
        .assetIssue,
        .contract,
    ]
}

#endif // swift(>=4.2)

// MARK: - Protocol_ReasonCode

enum Protocol_ReasonCode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case requested // = 0
    case badProtocol // = 2
    case tooManyPeers // = 4
    case duplicatePeer // = 5
    case incompatibleProtocol // = 6
    case randomElimination // = 7
    case peerQuiting // = 8
    case unexpectedIdentity // = 9
    case localIdentity // = 10
    case pingTimeout // = 11
    case userReason // = 16
    case reset // = 17
    case syncFail // = 18
    case fetchFail // = 19
    case badTx // = 20
    case badBlock // = 21
    case forked // = 22
    case unlinkable // = 23
    case incompatibleVersion // = 24
    case incompatibleChain // = 25
    case timeOut // = 32
    case connectFail // = 33
    case tooManyPeersWithSameIp // = 34
    case lightNodeSyncFail // = 35
    case unknown // = 255
    case UNRECOGNIZED(Int)

    init() {
        self = .requested
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .requested
        case 2: self = .badProtocol
        case 4: self = .tooManyPeers
        case 5: self = .duplicatePeer
        case 6: self = .incompatibleProtocol
        case 7: self = .randomElimination
        case 8: self = .peerQuiting
        case 9: self = .unexpectedIdentity
        case 10: self = .localIdentity
        case 11: self = .pingTimeout
        case 16: self = .userReason
        case 17: self = .reset
        case 18: self = .syncFail
        case 19: self = .fetchFail
        case 20: self = .badTx
        case 21: self = .badBlock
        case 22: self = .forked
        case 23: self = .unlinkable
        case 24: self = .incompatibleVersion
        case 25: self = .incompatibleChain
        case 32: self = .timeOut
        case 33: self = .connectFail
        case 34: self = .tooManyPeersWithSameIp
        case 35: self = .lightNodeSyncFail
        case 255: self = .unknown
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .requested: 0
        case .badProtocol: 2
        case .tooManyPeers: 4
        case .duplicatePeer: 5
        case .incompatibleProtocol: 6
        case .randomElimination: 7
        case .peerQuiting: 8
        case .unexpectedIdentity: 9
        case .localIdentity: 10
        case .pingTimeout: 11
        case .userReason: 16
        case .reset: 17
        case .syncFail: 18
        case .fetchFail: 19
        case .badTx: 20
        case .badBlock: 21
        case .forked: 22
        case .unlinkable: 23
        case .incompatibleVersion: 24
        case .incompatibleChain: 25
        case .timeOut: 32
        case .connectFail: 33
        case .tooManyPeersWithSameIp: 34
        case .lightNodeSyncFail: 35
        case .unknown: 255
        case .UNRECOGNIZED(let i): i
        }
    }
}

#if swift(>=4.2)

extension Protocol_ReasonCode: CaseIterable {
    /// The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Protocol_ReasonCode] = [
        .requested,
        .badProtocol,
        .tooManyPeers,
        .duplicatePeer,
        .incompatibleProtocol,
        .randomElimination,
        .peerQuiting,
        .unexpectedIdentity,
        .localIdentity,
        .pingTimeout,
        .userReason,
        .reset,
        .syncFail,
        .fetchFail,
        .badTx,
        .badBlock,
        .forked,
        .unlinkable,
        .incompatibleVersion,
        .incompatibleChain,
        .timeOut,
        .connectFail,
        .tooManyPeersWithSameIp,
        .lightNodeSyncFail,
        .unknown,
    ]
}

#endif // swift(>=4.2)

// MARK: - Protocol_AccountID

/// AccountId, (name, address) use name, (null, address) use address, (name, null) use name,
struct Protocol_AccountID {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: Data = .init()

    var address: Data = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_Vote

/// vote message
struct Protocol_Vote {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the super rep address
    var voteAddress: Data = .init()

    /// the vote num to this super rep.
    var voteCount: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_Proposal

/// Proposal
struct Protocol_Proposal {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var proposalID: Int64 = 0

    var proposerAddress: Data = .init()

    var parameters: [Int64: Int64] = [:]

    var expirationTime: Int64 = 0

    var createTime: Int64 = 0

    var approvals: [Data] = []

    var state: Protocol_Proposal.State = .pending

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum State: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case pending // = 0
        case disapproved // = 1
        case approved // = 2
        case canceled // = 3
        case UNRECOGNIZED(Int)

        init() {
            self = .pending
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .pending
            case 1: self = .disapproved
            case 2: self = .approved
            case 3: self = .canceled
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .pending: 0
            case .disapproved: 1
            case .approved: 2
            case .canceled: 3
            case .UNRECOGNIZED(let i): i
            }
        }
    }

    init() { }
}

#if swift(>=4.2)

extension Protocol_Proposal.State: CaseIterable {
    /// The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Protocol_Proposal.State] = [
        .pending,
        .disapproved,
        .approved,
        .canceled,
    ]
}

#endif // swift(>=4.2)

// MARK: - Protocol_Exchange

/// Exchange
struct Protocol_Exchange {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var exchangeID: Int64 = 0

    var creatorAddress: Data = .init()

    var createTime: Int64 = 0

    var firstTokenID: Data = .init()

    var firstTokenBalance: Int64 = 0

    var secondTokenID: Data = .init()

    var secondTokenBalance: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_MarketOrder

/// market
struct Protocol_MarketOrder {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var orderID: Data = .init()

    var ownerAddress: Data = .init()

    var createTime: Int64 = 0

    var sellTokenID: Data = .init()

    var sellTokenQuantity: Int64 = 0

    var buyTokenID: Data = .init()

    /// min to receive
    var buyTokenQuantity: Int64 = 0

    var sellTokenQuantityRemain: Int64 = 0

    /// When state != ACTIVE and sell_token_quantity_return !=0,
    /// it means that some sell tokens are returned to the account due to insufficient remaining amount
    var sellTokenQuantityReturn: Int64 = 0

    var state: Protocol_MarketOrder.State = .active

    var prev: Data = .init()

    var next: Data = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum State: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case active // = 0
        case inactive // = 1
        case canceled // = 2
        case UNRECOGNIZED(Int)

        init() {
            self = .active
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .active
            case 1: self = .inactive
            case 2: self = .canceled
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .active: 0
            case .inactive: 1
            case .canceled: 2
            case .UNRECOGNIZED(let i): i
            }
        }
    }

    init() { }
}

#if swift(>=4.2)

extension Protocol_MarketOrder.State: CaseIterable {
    /// The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Protocol_MarketOrder.State] = [
        .active,
        .inactive,
        .canceled,
    ]
}

#endif // swift(>=4.2)

// MARK: - Protocol_MarketOrderList

struct Protocol_MarketOrderList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var orders: [Protocol_MarketOrder] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_MarketOrderPairList

struct Protocol_MarketOrderPairList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var orderPair: [Protocol_MarketOrderPair] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_MarketOrderPair

struct Protocol_MarketOrderPair {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sellTokenID: Data = .init()

    var buyTokenID: Data = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_MarketAccountOrder

struct Protocol_MarketAccountOrder {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ownerAddress: Data = .init()

    /// order_id list
    var orders: [Data] = []

    /// active count
    var count: Int64 = 0

    var totalCount: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_MarketPrice

struct Protocol_MarketPrice {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sellTokenQuantity: Int64 = 0

    var buyTokenQuantity: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_MarketPriceList

struct Protocol_MarketPriceList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sellTokenID: Data = .init()

    var buyTokenID: Data = .init()

    var prices: [Protocol_MarketPrice] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_MarketOrderIDList

struct Protocol_MarketOrderIDList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var head: Data = .init()

    var tail: Data = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_ChainParameters

struct Protocol_ChainParameters {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var chainParameter: [Protocol_ChainParameters.ChainParameter] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct ChainParameter {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var key: String = .init()

        var value: Int64 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() { }
    }

    init() { }
}

// MARK: - Protocol_Account

/// Account
struct Protocol_Account {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// account nick name
    var accountName: Data {
        get { _storage._accountName }
        set { _uniqueStorage()._accountName = newValue }
    }

    var type: Protocol_AccountType {
        get { _storage._type }
        set { _uniqueStorage()._type = newValue }
    }

    /// the create address
    var address: Data {
        get { _storage._address }
        set { _uniqueStorage()._address = newValue }
    }

    /// the trx balance
    var balance: Int64 {
        get { _storage._balance }
        set { _uniqueStorage()._balance = newValue }
    }

    /// the votes
    var votes: [Protocol_Vote] {
        get { _storage._votes }
        set { _uniqueStorage()._votes = newValue }
    }

    /// the other asset owned by this account
    var asset: [String: Int64] {
        get { _storage._asset }
        set { _uniqueStorage()._asset = newValue }
    }

    /// the other asset owned by this account，key is assetID
    var assetV2: [String: Int64] {
        get { _storage._assetV2 }
        set { _uniqueStorage()._assetV2 = newValue }
    }

    /// the frozen balance for bandwidth
    var frozen: [Protocol_Account.Frozen] {
        get { _storage._frozen }
        set { _uniqueStorage()._frozen = newValue }
    }

    /// bandwidth, get from frozen
    var netUsage: Int64 {
        get { _storage._netUsage }
        set { _uniqueStorage()._netUsage = newValue }
    }

    /// Frozen balance provided by other accounts to this account
    var acquiredDelegatedFrozenBalanceForBandwidth: Int64 {
        get { _storage._acquiredDelegatedFrozenBalanceForBandwidth }
        set { _uniqueStorage()._acquiredDelegatedFrozenBalanceForBandwidth = newValue }
    }

    /// Freeze and provide balances to other accounts
    var delegatedFrozenBalanceForBandwidth: Int64 {
        get { _storage._delegatedFrozenBalanceForBandwidth }
        set { _uniqueStorage()._delegatedFrozenBalanceForBandwidth = newValue }
    }

    var oldTronPower: Int64 {
        get { _storage._oldTronPower }
        set { _uniqueStorage()._oldTronPower = newValue }
    }

    var tronPower: Protocol_Account.Frozen {
        get { _storage._tronPower ?? Protocol_Account.Frozen() }
        set { _uniqueStorage()._tronPower = newValue }
    }

    /// Returns true if `tronPower` has been explicitly set.
    var hasTronPower: Bool { _storage._tronPower != nil }
    /// Clears the value of `tronPower`. Subsequent reads from it will return its default value.
    mutating func clearTronPower() { _uniqueStorage()._tronPower = nil }

    var assetOptimized: Bool {
        get { _storage._assetOptimized }
        set { _uniqueStorage()._assetOptimized = newValue }
    }

    /// this account create time
    var createTime: Int64 {
        get { _storage._createTime }
        set { _uniqueStorage()._createTime = newValue }
    }

    /// this last operation time, including transfer, voting and so on. //FIXME fix grammar
    var latestOprationTime: Int64 {
        get { _storage._latestOprationTime }
        set { _uniqueStorage()._latestOprationTime = newValue }
    }

    /// witness block producing allowance
    var allowance: Int64 {
        get { _storage._allowance }
        set { _uniqueStorage()._allowance = newValue }
    }

    /// last withdraw time
    var latestWithdrawTime: Int64 {
        get { _storage._latestWithdrawTime }
        set { _uniqueStorage()._latestWithdrawTime = newValue }
    }

    /// not used so far
    var code: Data {
        get { _storage._code }
        set { _uniqueStorage()._code = newValue }
    }

    var isWitness: Bool {
        get { _storage._isWitness }
        set { _uniqueStorage()._isWitness = newValue }
    }

    var isCommittee: Bool {
        get { _storage._isCommittee }
        set { _uniqueStorage()._isCommittee = newValue }
    }

    /// frozen asset(for asset issuer)
    var frozenSupply: [Protocol_Account.Frozen] {
        get { _storage._frozenSupply }
        set { _uniqueStorage()._frozenSupply = newValue }
    }

    /// asset_issued_name
    var assetIssuedName: Data {
        get { _storage._assetIssuedName }
        set { _uniqueStorage()._assetIssuedName = newValue }
    }

    var assetIssuedID: Data {
        get { _storage._assetIssuedID }
        set { _uniqueStorage()._assetIssuedID = newValue }
    }

    var latestAssetOperationTime: [String: Int64] {
        get { _storage._latestAssetOperationTime }
        set { _uniqueStorage()._latestAssetOperationTime = newValue }
    }

    var latestAssetOperationTimeV2: [String: Int64] {
        get { _storage._latestAssetOperationTimeV2 }
        set { _uniqueStorage()._latestAssetOperationTimeV2 = newValue }
    }

    var freeNetUsage: Int64 {
        get { _storage._freeNetUsage }
        set { _uniqueStorage()._freeNetUsage = newValue }
    }

    var freeAssetNetUsage: [String: Int64] {
        get { _storage._freeAssetNetUsage }
        set { _uniqueStorage()._freeAssetNetUsage = newValue }
    }

    var freeAssetNetUsageV2: [String: Int64] {
        get { _storage._freeAssetNetUsageV2 }
        set { _uniqueStorage()._freeAssetNetUsageV2 = newValue }
    }

    var latestConsumeTime: Int64 {
        get { _storage._latestConsumeTime }
        set { _uniqueStorage()._latestConsumeTime = newValue }
    }

    var latestConsumeFreeTime: Int64 {
        get { _storage._latestConsumeFreeTime }
        set { _uniqueStorage()._latestConsumeFreeTime = newValue }
    }

    /// the identity of this account, case insensitive
    var accountID: Data {
        get { _storage._accountID }
        set { _uniqueStorage()._accountID = newValue }
    }

    var netWindowSize: Int64 {
        get { _storage._netWindowSize }
        set { _uniqueStorage()._netWindowSize = newValue }
    }

    var accountResource: Protocol_Account.AccountResource {
        get { _storage._accountResource ?? Protocol_Account.AccountResource() }
        set { _uniqueStorage()._accountResource = newValue }
    }

    /// Returns true if `accountResource` has been explicitly set.
    var hasAccountResource: Bool { _storage._accountResource != nil }
    /// Clears the value of `accountResource`. Subsequent reads from it will return its default value.
    mutating func clearAccountResource() { _uniqueStorage()._accountResource = nil }

    var codeHash: Data {
        get { _storage._codeHash }
        set { _uniqueStorage()._codeHash = newValue }
    }

    var ownerPermission: Protocol_Permission {
        get { _storage._ownerPermission ?? Protocol_Permission() }
        set { _uniqueStorage()._ownerPermission = newValue }
    }

    /// Returns true if `ownerPermission` has been explicitly set.
    var hasOwnerPermission: Bool { _storage._ownerPermission != nil }
    /// Clears the value of `ownerPermission`. Subsequent reads from it will return its default value.
    mutating func clearOwnerPermission() { _uniqueStorage()._ownerPermission = nil }

    var witnessPermission: Protocol_Permission {
        get { _storage._witnessPermission ?? Protocol_Permission() }
        set { _uniqueStorage()._witnessPermission = newValue }
    }

    /// Returns true if `witnessPermission` has been explicitly set.
    var hasWitnessPermission: Bool { _storage._witnessPermission != nil }
    /// Clears the value of `witnessPermission`. Subsequent reads from it will return its default value.
    mutating func clearWitnessPermission() { _uniqueStorage()._witnessPermission = nil }

    var activePermission: [Protocol_Permission] {
        get { _storage._activePermission }
        set { _uniqueStorage()._activePermission = newValue }
    }

    var frozenV2: [Protocol_Account.FreezeV2] {
        get { _storage._frozenV2 }
        set { _uniqueStorage()._frozenV2 = newValue }
    }

    var unfrozenV2: [Protocol_Account.UnFreezeV2] {
        get { _storage._unfrozenV2 }
        set { _uniqueStorage()._unfrozenV2 = newValue }
    }

    var delegatedFrozenV2BalanceForBandwidth: Int64 {
        get { _storage._delegatedFrozenV2BalanceForBandwidth }
        set { _uniqueStorage()._delegatedFrozenV2BalanceForBandwidth = newValue }
    }

    var acquiredDelegatedFrozenV2BalanceForBandwidth: Int64 {
        get { _storage._acquiredDelegatedFrozenV2BalanceForBandwidth }
        set { _uniqueStorage()._acquiredDelegatedFrozenV2BalanceForBandwidth = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// frozen balance
    struct Frozen {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// the frozen trx balance
        var frozenBalance: Int64 = 0

        /// the expire time
        var expireTime: Int64 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() { }
    }

    struct AccountResource {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// energy resource, get from frozen
        var energyUsage: Int64 = 0

        /// the frozen balance for energy
        var frozenBalanceForEnergy: Protocol_Account.Frozen {
            get { _frozenBalanceForEnergy ?? Protocol_Account.Frozen() }
            set { _frozenBalanceForEnergy = newValue }
        }

        /// Returns true if `frozenBalanceForEnergy` has been explicitly set.
        var hasFrozenBalanceForEnergy: Bool { _frozenBalanceForEnergy != nil }
        /// Clears the value of `frozenBalanceForEnergy`. Subsequent reads from it will return its default value.
        mutating func clearFrozenBalanceForEnergy() { _frozenBalanceForEnergy = nil }

        var latestConsumeTimeForEnergy: Int64 = 0

        /// Frozen balance provided by other accounts to this account
        var acquiredDelegatedFrozenBalanceForEnergy: Int64 = 0

        /// Frozen balances provided to other accounts
        var delegatedFrozenBalanceForEnergy: Int64 = 0

        /// storage resource, get from market
        var storageLimit: Int64 = 0

        var storageUsage: Int64 = 0

        var latestExchangeStorageTime: Int64 = 0

        var energyWindowSize: Int64 = 0

        var delegatedFrozenV2BalanceForEnergy: Int64 = 0

        var acquiredDelegatedFrozenV2BalanceForEnergy: Int64 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() { }

        fileprivate var _frozenBalanceForEnergy: Protocol_Account.Frozen? = nil
    }

    struct FreezeV2 {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var type: Protocol_ResourceCode = .bandwidth

        var amount: Int64 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() { }
    }

    struct UnFreezeV2 {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var type: Protocol_ResourceCode = .bandwidth

        var unfreezeAmount: Int64 = 0

        var unfreezeExpireTime: Int64 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() { }
    }

    init() { }

    fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Protocol_Key

struct Protocol_Key {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var address: Data = .init()

    var weight: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_DelegatedResource

struct Protocol_DelegatedResource {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var from: Data = .init()

    var to: Data = .init()

    var frozenBalanceForBandwidth: Int64 = 0

    var frozenBalanceForEnergy: Int64 = 0

    var expireTimeForBandwidth: Int64 = 0

    var expireTimeForEnergy: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_authority

struct Protocol_authority {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var account: Protocol_AccountID {
        get { _account ?? Protocol_AccountID() }
        set { _account = newValue }
    }

    /// Returns true if `account` has been explicitly set.
    var hasAccount: Bool { _account != nil }
    /// Clears the value of `account`. Subsequent reads from it will return its default value.
    mutating func clearAccount() { _account = nil }

    var permissionName: Data = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }

    private var _account: Protocol_AccountID? = nil
}

// MARK: - Protocol_Permission

struct Protocol_Permission {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: Protocol_Permission.PermissionType = .owner

    /// Owner id=0, Witness id=1, Active id start by 2
    var id: Int32 = 0

    var permissionName: String = .init()

    var threshold: Int64 = 0

    var parentID: Int32 = 0

    /// 1 bit 1 contract
    var operations: Data = .init()

    var keys: [Protocol_Key] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum PermissionType: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case owner // = 0
        case witness // = 1
        case active // = 2
        case UNRECOGNIZED(Int)

        init() {
            self = .owner
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .owner
            case 1: self = .witness
            case 2: self = .active
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .owner: 0
            case .witness: 1
            case .active: 2
            case .UNRECOGNIZED(let i): i
            }
        }
    }

    init() { }
}

#if swift(>=4.2)

extension Protocol_Permission.PermissionType: CaseIterable {
    /// The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Protocol_Permission.PermissionType] = [
        .owner,
        .witness,
        .active,
    ]
}

#endif // swift(>=4.2)

// MARK: - Protocol_Witness

/// Witness
struct Protocol_Witness {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var address: Data = .init()

    var voteCount: Int64 = 0

    var pubKey: Data = .init()

    var url: String = .init()

    var totalProduced: Int64 = 0

    var totalMissed: Int64 = 0

    var latestBlockNum: Int64 = 0

    var latestSlotNum: Int64 = 0

    var isJobs = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_Votes

/// Vote Change
struct Protocol_Votes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var address: Data = .init()

    var oldVotes: [Protocol_Vote] = []

    var newVotes: [Protocol_Vote] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_TXOutput

struct Protocol_TXOutput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: Int64 = 0

    var pubKeyHash: Data = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_TXInput

struct Protocol_TXInput {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rawData: Protocol_TXInput.raw {
        get { _rawData ?? Protocol_TXInput.raw() }
        set { _rawData = newValue }
    }

    /// Returns true if `rawData` has been explicitly set.
    var hasRawData: Bool { _rawData != nil }
    /// Clears the value of `rawData`. Subsequent reads from it will return its default value.
    mutating func clearRawData() { _rawData = nil }

    var signature: Data = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct raw {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var txID: Data = .init()

        var vout: Int64 = 0

        var pubKey: Data = .init()

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() { }
    }

    init() { }

    fileprivate var _rawData: Protocol_TXInput.raw? = nil
}

// MARK: - Protocol_TXOutputs

struct Protocol_TXOutputs {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var outputs: [Protocol_TXOutput] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_ResourceReceipt

struct Protocol_ResourceReceipt {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var energyUsage: Int64 = 0

    var energyFee: Int64 = 0

    var originEnergyUsage: Int64 = 0

    var energyUsageTotal: Int64 = 0

    var netUsage: Int64 = 0

    var netFee: Int64 = 0

    var result: Protocol_Transaction.Result.contractResult = .default

    var energyPenaltyTotal: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_MarketOrderDetail

struct Protocol_MarketOrderDetail {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var makerOrderID: Data = .init()

    var takerOrderID: Data = .init()

    var fillSellQuantity: Int64 = 0

    var fillBuyQuantity: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_Transaction

struct Protocol_Transaction {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rawData: Protocol_Transaction.raw {
        get { _rawData ?? Protocol_Transaction.raw() }
        set { _rawData = newValue }
    }

    /// Returns true if `rawData` has been explicitly set.
    var hasRawData: Bool { _rawData != nil }
    /// Clears the value of `rawData`. Subsequent reads from it will return its default value.
    mutating func clearRawData() { _rawData = nil }

    /// only support size = 1,  repeated list here for muti-sig extension
    var signature: [Data] = []

    var ret: [Protocol_Transaction.Result] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Contract {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var type: Protocol_Transaction.Contract.ContractType = .accountCreateContract

        var parameter: SwiftProtobuf.Google_Protobuf_Any {
            get { _parameter ?? SwiftProtobuf.Google_Protobuf_Any() }
            set { _parameter = newValue }
        }

        /// Returns true if `parameter` has been explicitly set.
        var hasParameter: Bool { _parameter != nil }
        /// Clears the value of `parameter`. Subsequent reads from it will return its default value.
        mutating func clearParameter() { _parameter = nil }

        var provider: Data = .init()

        var contractName: Data = .init()

        var permissionID: Int32 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum ContractType: SwiftProtobuf.Enum {
            typealias RawValue = Int
            case accountCreateContract // = 0
            case transferContract // = 1
            case transferAssetContract // = 2
            case voteAssetContract // = 3
            case voteWitnessContract // = 4
            case witnessCreateContract // = 5
            case assetIssueContract // = 6
            case witnessUpdateContract // = 8
            case participateAssetIssueContract // = 9
            case accountUpdateContract // = 10
            case freezeBalanceContract // = 11
            case unfreezeBalanceContract // = 12
            case withdrawBalanceContract // = 13
            case unfreezeAssetContract // = 14
            case updateAssetContract // = 15
            case proposalCreateContract // = 16
            case proposalApproveContract // = 17
            case proposalDeleteContract // = 18
            case setAccountIDContract // = 19
            case customContract // = 20
            case createSmartContract // = 30
            case triggerSmartContract // = 31
            case getContract // = 32
            case updateSettingContract // = 33
            case exchangeCreateContract // = 41
            case exchangeInjectContract // = 42
            case exchangeWithdrawContract // = 43
            case exchangeTransactionContract // = 44
            case updateEnergyLimitContract // = 45
            case accountPermissionUpdateContract // = 46
            case clearAbicontract // = 48
            case updateBrokerageContract // = 49
            case shieldedTransferContract // = 51
            case marketSellAssetContract // = 52
            case marketCancelOrderContract // = 53
            case freezeBalanceV2Contract // = 54
            case unfreezeBalanceV2Contract // = 55
            case withdrawExpireUnfreezeContract // = 56
            case delegateResourceContract // = 57
            case unDelegateResourceContract // = 58
            case UNRECOGNIZED(Int)

            init() {
                self = .accountCreateContract
            }

            init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .accountCreateContract
                case 1: self = .transferContract
                case 2: self = .transferAssetContract
                case 3: self = .voteAssetContract
                case 4: self = .voteWitnessContract
                case 5: self = .witnessCreateContract
                case 6: self = .assetIssueContract
                case 8: self = .witnessUpdateContract
                case 9: self = .participateAssetIssueContract
                case 10: self = .accountUpdateContract
                case 11: self = .freezeBalanceContract
                case 12: self = .unfreezeBalanceContract
                case 13: self = .withdrawBalanceContract
                case 14: self = .unfreezeAssetContract
                case 15: self = .updateAssetContract
                case 16: self = .proposalCreateContract
                case 17: self = .proposalApproveContract
                case 18: self = .proposalDeleteContract
                case 19: self = .setAccountIDContract
                case 20: self = .customContract
                case 30: self = .createSmartContract
                case 31: self = .triggerSmartContract
                case 32: self = .getContract
                case 33: self = .updateSettingContract
                case 41: self = .exchangeCreateContract
                case 42: self = .exchangeInjectContract
                case 43: self = .exchangeWithdrawContract
                case 44: self = .exchangeTransactionContract
                case 45: self = .updateEnergyLimitContract
                case 46: self = .accountPermissionUpdateContract
                case 48: self = .clearAbicontract
                case 49: self = .updateBrokerageContract
                case 51: self = .shieldedTransferContract
                case 52: self = .marketSellAssetContract
                case 53: self = .marketCancelOrderContract
                case 54: self = .freezeBalanceV2Contract
                case 55: self = .unfreezeBalanceV2Contract
                case 56: self = .withdrawExpireUnfreezeContract
                case 57: self = .delegateResourceContract
                case 58: self = .unDelegateResourceContract
                default: self = .UNRECOGNIZED(rawValue)
                }
            }

            var rawValue: Int {
                switch self {
                case .accountCreateContract: 0
                case .transferContract: 1
                case .transferAssetContract: 2
                case .voteAssetContract: 3
                case .voteWitnessContract: 4
                case .witnessCreateContract: 5
                case .assetIssueContract: 6
                case .witnessUpdateContract: 8
                case .participateAssetIssueContract: 9
                case .accountUpdateContract: 10
                case .freezeBalanceContract: 11
                case .unfreezeBalanceContract: 12
                case .withdrawBalanceContract: 13
                case .unfreezeAssetContract: 14
                case .updateAssetContract: 15
                case .proposalCreateContract: 16
                case .proposalApproveContract: 17
                case .proposalDeleteContract: 18
                case .setAccountIDContract: 19
                case .customContract: 20
                case .createSmartContract: 30
                case .triggerSmartContract: 31
                case .getContract: 32
                case .updateSettingContract: 33
                case .exchangeCreateContract: 41
                case .exchangeInjectContract: 42
                case .exchangeWithdrawContract: 43
                case .exchangeTransactionContract: 44
                case .updateEnergyLimitContract: 45
                case .accountPermissionUpdateContract: 46
                case .clearAbicontract: 48
                case .updateBrokerageContract: 49
                case .shieldedTransferContract: 51
                case .marketSellAssetContract: 52
                case .marketCancelOrderContract: 53
                case .freezeBalanceV2Contract: 54
                case .unfreezeBalanceV2Contract: 55
                case .withdrawExpireUnfreezeContract: 56
                case .delegateResourceContract: 57
                case .unDelegateResourceContract: 58
                case .UNRECOGNIZED(let i): i
                }
            }
        }

        init() { }

        fileprivate var _parameter: SwiftProtobuf.Google_Protobuf_Any? = nil
    }

    struct Result {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var fee: Int64 = 0

        var ret: Protocol_Transaction.Result.code = .sucess

        var contractRet: Protocol_Transaction.Result.contractResult = .default

        var assetIssueID: String = .init()

        var withdrawAmount: Int64 = 0

        var unfreezeAmount: Int64 = 0

        var exchangeReceivedAmount: Int64 = 0

        var exchangeInjectAnotherAmount: Int64 = 0

        var exchangeWithdrawAnotherAmount: Int64 = 0

        var exchangeID: Int64 = 0

        var shieldedTransactionFee: Int64 = 0

        var orderID: Data = .init()

        var orderDetails: [Protocol_MarketOrderDetail] = []

        var withdrawExpireAmount: Int64 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum code: SwiftProtobuf.Enum {
            typealias RawValue = Int
            case sucess // = 0
            case failed // = 1
            case UNRECOGNIZED(Int)

            init() {
                self = .sucess
            }

            init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .sucess
                case 1: self = .failed
                default: self = .UNRECOGNIZED(rawValue)
                }
            }

            var rawValue: Int {
                switch self {
                case .sucess: 0
                case .failed: 1
                case .UNRECOGNIZED(let i): i
                }
            }
        }

        enum contractResult: SwiftProtobuf.Enum {
            typealias RawValue = Int
            case `default` // = 0
            case success // = 1
            case revert // = 2
            case badJumpDestination // = 3
            case outOfMemory // = 4
            case precompiledContract // = 5
            case stackTooSmall // = 6
            case stackTooLarge // = 7
            case illegalOperation // = 8
            case stackOverflow // = 9
            case outOfEnergy // = 10
            case outOfTime // = 11
            case jvmStackOverFlow // = 12
            case unknown // = 13
            case transferFailed // = 14
            case invalidCode // = 15
            case UNRECOGNIZED(Int)

            init() {
                self = .default
            }

            init?(rawValue: Int) {
                switch rawValue {
                case 0: self = .default
                case 1: self = .success
                case 2: self = .revert
                case 3: self = .badJumpDestination
                case 4: self = .outOfMemory
                case 5: self = .precompiledContract
                case 6: self = .stackTooSmall
                case 7: self = .stackTooLarge
                case 8: self = .illegalOperation
                case 9: self = .stackOverflow
                case 10: self = .outOfEnergy
                case 11: self = .outOfTime
                case 12: self = .jvmStackOverFlow
                case 13: self = .unknown
                case 14: self = .transferFailed
                case 15: self = .invalidCode
                default: self = .UNRECOGNIZED(rawValue)
                }
            }

            var rawValue: Int {
                switch self {
                case .default: 0
                case .success: 1
                case .revert: 2
                case .badJumpDestination: 3
                case .outOfMemory: 4
                case .precompiledContract: 5
                case .stackTooSmall: 6
                case .stackTooLarge: 7
                case .illegalOperation: 8
                case .stackOverflow: 9
                case .outOfEnergy: 10
                case .outOfTime: 11
                case .jvmStackOverFlow: 12
                case .unknown: 13
                case .transferFailed: 14
                case .invalidCode: 15
                case .UNRECOGNIZED(let i): i
                }
            }
        }

        init() { }
    }

    struct raw {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var refBlockBytes: Data = .init()

        var refBlockNum: Int64 = 0

        var refBlockHash: Data = .init()

        var expiration: Int64 = 0

        var auths: [Protocol_authority] = []

        /// data not used
        var data: Data = .init()

        /// only support size = 1,  repeated list here for extension
        var contract: [Protocol_Transaction.Contract] = []

        /// scripts not used
        var scripts: Data = .init()

        var timestamp: Int64 = 0

        var feeLimit: Int64 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() { }
    }

    init() { }

    fileprivate var _rawData: Protocol_Transaction.raw? = nil
}

#if swift(>=4.2)

extension Protocol_Transaction.Contract.ContractType: CaseIterable {
    /// The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Protocol_Transaction.Contract.ContractType] = [
        .accountCreateContract,
        .transferContract,
        .transferAssetContract,
        .voteAssetContract,
        .voteWitnessContract,
        .witnessCreateContract,
        .assetIssueContract,
        .witnessUpdateContract,
        .participateAssetIssueContract,
        .accountUpdateContract,
        .freezeBalanceContract,
        .unfreezeBalanceContract,
        .withdrawBalanceContract,
        .unfreezeAssetContract,
        .updateAssetContract,
        .proposalCreateContract,
        .proposalApproveContract,
        .proposalDeleteContract,
        .setAccountIDContract,
        .customContract,
        .createSmartContract,
        .triggerSmartContract,
        .getContract,
        .updateSettingContract,
        .exchangeCreateContract,
        .exchangeInjectContract,
        .exchangeWithdrawContract,
        .exchangeTransactionContract,
        .updateEnergyLimitContract,
        .accountPermissionUpdateContract,
        .clearAbicontract,
        .updateBrokerageContract,
        .shieldedTransferContract,
        .marketSellAssetContract,
        .marketCancelOrderContract,
        .freezeBalanceV2Contract,
        .unfreezeBalanceV2Contract,
        .withdrawExpireUnfreezeContract,
        .delegateResourceContract,
        .unDelegateResourceContract,
    ]
}

extension Protocol_Transaction.Result.code: CaseIterable {
    /// The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Protocol_Transaction.Result.code] = [
        .sucess,
        .failed,
    ]
}

extension Protocol_Transaction.Result.contractResult: CaseIterable {
    /// The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Protocol_Transaction.Result.contractResult] = [
        .default,
        .success,
        .revert,
        .badJumpDestination,
        .outOfMemory,
        .precompiledContract,
        .stackTooSmall,
        .stackTooLarge,
        .illegalOperation,
        .stackOverflow,
        .outOfEnergy,
        .outOfTime,
        .jvmStackOverFlow,
        .unknown,
        .transferFailed,
        .invalidCode,
    ]
}

#endif // swift(>=4.2)

// MARK: - Protocol_TransactionInfo

struct Protocol_TransactionInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: Data {
        get { _storage._id }
        set { _uniqueStorage()._id = newValue }
    }

    var fee: Int64 {
        get { _storage._fee }
        set { _uniqueStorage()._fee = newValue }
    }

    var blockNumber: Int64 {
        get { _storage._blockNumber }
        set { _uniqueStorage()._blockNumber = newValue }
    }

    var blockTimeStamp: Int64 {
        get { _storage._blockTimeStamp }
        set { _uniqueStorage()._blockTimeStamp = newValue }
    }

    var contractResult: [Data] {
        get { _storage._contractResult }
        set { _uniqueStorage()._contractResult = newValue }
    }

    var contractAddress: Data {
        get { _storage._contractAddress }
        set { _uniqueStorage()._contractAddress = newValue }
    }

    var receipt: Protocol_ResourceReceipt {
        get { _storage._receipt ?? Protocol_ResourceReceipt() }
        set { _uniqueStorage()._receipt = newValue }
    }

    /// Returns true if `receipt` has been explicitly set.
    var hasReceipt: Bool { _storage._receipt != nil }
    /// Clears the value of `receipt`. Subsequent reads from it will return its default value.
    mutating func clearReceipt() { _uniqueStorage()._receipt = nil }

    var log: [Protocol_TransactionInfo.Log] {
        get { _storage._log }
        set { _uniqueStorage()._log = newValue }
    }

    var result: Protocol_TransactionInfo.code {
        get { _storage._result }
        set { _uniqueStorage()._result = newValue }
    }

    var resMessage: Data {
        get { _storage._resMessage }
        set { _uniqueStorage()._resMessage = newValue }
    }

    var assetIssueID: String {
        get { _storage._assetIssueID }
        set { _uniqueStorage()._assetIssueID = newValue }
    }

    var withdrawAmount: Int64 {
        get { _storage._withdrawAmount }
        set { _uniqueStorage()._withdrawAmount = newValue }
    }

    var unfreezeAmount: Int64 {
        get { _storage._unfreezeAmount }
        set { _uniqueStorage()._unfreezeAmount = newValue }
    }

    var internalTransactions: [Protocol_InternalTransaction] {
        get { _storage._internalTransactions }
        set { _uniqueStorage()._internalTransactions = newValue }
    }

    var exchangeReceivedAmount: Int64 {
        get { _storage._exchangeReceivedAmount }
        set { _uniqueStorage()._exchangeReceivedAmount = newValue }
    }

    var exchangeInjectAnotherAmount: Int64 {
        get { _storage._exchangeInjectAnotherAmount }
        set { _uniqueStorage()._exchangeInjectAnotherAmount = newValue }
    }

    var exchangeWithdrawAnotherAmount: Int64 {
        get { _storage._exchangeWithdrawAnotherAmount }
        set { _uniqueStorage()._exchangeWithdrawAnotherAmount = newValue }
    }

    var exchangeID: Int64 {
        get { _storage._exchangeID }
        set { _uniqueStorage()._exchangeID = newValue }
    }

    var shieldedTransactionFee: Int64 {
        get { _storage._shieldedTransactionFee }
        set { _uniqueStorage()._shieldedTransactionFee = newValue }
    }

    var orderID: Data {
        get { _storage._orderID }
        set { _uniqueStorage()._orderID = newValue }
    }

    var orderDetails: [Protocol_MarketOrderDetail] {
        get { _storage._orderDetails }
        set { _uniqueStorage()._orderDetails = newValue }
    }

    var packingFee: Int64 {
        get { _storage._packingFee }
        set { _uniqueStorage()._packingFee = newValue }
    }

    var withdrawExpireAmount: Int64 {
        get { _storage._withdrawExpireAmount }
        set { _uniqueStorage()._withdrawExpireAmount = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum code: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case sucess // = 0
        case failed // = 1
        case UNRECOGNIZED(Int)

        init() {
            self = .sucess
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .sucess
            case 1: self = .failed
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .sucess: 0
            case .failed: 1
            case .UNRECOGNIZED(let i): i
            }
        }
    }

    struct Log {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var address: Data = .init()

        var topics: [Data] = []

        var data: Data = .init()

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() { }
    }

    init() { }

    fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Protocol_TransactionInfo.code: CaseIterable {
    /// The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Protocol_TransactionInfo.code] = [
        .sucess,
        .failed,
    ]
}

#endif // swift(>=4.2)

// MARK: - Protocol_TransactionRet

struct Protocol_TransactionRet {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var blockNumber: Int64 = 0

    var blockTimeStamp: Int64 = 0

    var transactioninfo: [Protocol_TransactionInfo] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_Transactions

struct Protocol_Transactions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var transactions: [Protocol_Transaction] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_BlockHeader

struct Protocol_BlockHeader {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rawData: Protocol_BlockHeader.raw {
        get { _rawData ?? Protocol_BlockHeader.raw() }
        set { _rawData = newValue }
    }

    /// Returns true if `rawData` has been explicitly set.
    var hasRawData: Bool { _rawData != nil }
    /// Clears the value of `rawData`. Subsequent reads from it will return its default value.
    mutating func clearRawData() { _rawData = nil }

    var witnessSignature: Data = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct raw {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var timestamp: Int64 = 0

        var txTrieRoot: Data = .init()

        var parentHash: Data = .init()

        /// bytes nonce = 5;
        /// bytes difficulty = 6;
        var number: Int64 = 0

        var witnessID: Int64 = 0

        var witnessAddress: Data = .init()

        var version: Int32 = 0

        var accountStateRoot: Data = .init()

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() { }
    }

    init() { }

    fileprivate var _rawData: Protocol_BlockHeader.raw? = nil
}

// MARK: - Protocol_Block

/// block
struct Protocol_Block {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var transactions: [Protocol_Transaction] = []

    var blockHeader: Protocol_BlockHeader {
        get { _blockHeader ?? Protocol_BlockHeader() }
        set { _blockHeader = newValue }
    }

    /// Returns true if `blockHeader` has been explicitly set.
    var hasBlockHeader: Bool { _blockHeader != nil }
    /// Clears the value of `blockHeader`. Subsequent reads from it will return its default value.
    mutating func clearBlockHeader() { _blockHeader = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }

    private var _blockHeader: Protocol_BlockHeader? = nil
}

// MARK: - Protocol_ChainInventory

struct Protocol_ChainInventory {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ids: [Protocol_ChainInventory.BlockID] = []

    var remainNum: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct BlockID {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var hash: Data = .init()

        var number: Int64 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() { }
    }

    init() { }
}

// MARK: - Protocol_BlockInventory

/// Inventory
struct Protocol_BlockInventory {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ids: [Protocol_BlockInventory.BlockID] = []

    var type: Protocol_BlockInventory.TypeEnum = .sync

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case sync // = 0
        case advtise // = 1
        case fetch // = 2
        case UNRECOGNIZED(Int)

        init() {
            self = .sync
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .sync
            case 1: self = .advtise
            case 2: self = .fetch
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .sync: 0
            case .advtise: 1
            case .fetch: 2
            case .UNRECOGNIZED(let i): i
            }
        }
    }

    struct BlockID {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var hash: Data = .init()

        var number: Int64 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() { }
    }

    init() { }
}

#if swift(>=4.2)

extension Protocol_BlockInventory.TypeEnum: CaseIterable {
    /// The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Protocol_BlockInventory.TypeEnum] = [
        .sync,
        .advtise,
        .fetch,
    ]
}

#endif // swift(>=4.2)

// MARK: - Protocol_Inventory

struct Protocol_Inventory {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: Protocol_Inventory.InventoryType = .trx

    var ids: [Data] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum InventoryType: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case trx // = 0
        case block // = 1
        case UNRECOGNIZED(Int)

        init() {
            self = .trx
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .trx
            case 1: self = .block
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .trx: 0
            case .block: 1
            case .UNRECOGNIZED(let i): i
            }
        }
    }

    init() { }
}

#if swift(>=4.2)

extension Protocol_Inventory.InventoryType: CaseIterable {
    /// The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Protocol_Inventory.InventoryType] = [
        .trx,
        .block,
    ]
}

#endif // swift(>=4.2)

// MARK: - Protocol_Items

struct Protocol_Items {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: Protocol_Items.ItemType = .err

    var blocks: [Protocol_Block] = []

    var blockHeaders: [Protocol_BlockHeader] = []

    var transactions: [Protocol_Transaction] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum ItemType: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case err // = 0
        case trx // = 1
        case block // = 2
        case blockheader // = 3
        case UNRECOGNIZED(Int)

        init() {
            self = .err
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .err
            case 1: self = .trx
            case 2: self = .block
            case 3: self = .blockheader
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .err: 0
            case .trx: 1
            case .block: 2
            case .blockheader: 3
            case .UNRECOGNIZED(let i): i
            }
        }
    }

    init() { }
}

#if swift(>=4.2)

extension Protocol_Items.ItemType: CaseIterable {
    /// The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Protocol_Items.ItemType] = [
        .err,
        .trx,
        .block,
        .blockheader,
    ]
}

#endif // swift(>=4.2)

// MARK: - Protocol_DynamicProperties

/// DynamicProperties
struct Protocol_DynamicProperties {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var lastSolidityBlockNum: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_DisconnectMessage

struct Protocol_DisconnectMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var reason: Protocol_ReasonCode = .requested

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_HelloMessage

struct Protocol_HelloMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var from: Protocol_Endpoint {
        get { _from ?? Protocol_Endpoint() }
        set { _from = newValue }
    }

    /// Returns true if `from` has been explicitly set.
    var hasFrom: Bool { _from != nil }
    /// Clears the value of `from`. Subsequent reads from it will return its default value.
    mutating func clearFrom() { _from = nil }

    var version: Int32 = 0

    var timestamp: Int64 = 0

    var genesisBlockID: Protocol_HelloMessage.BlockID {
        get { _genesisBlockID ?? Protocol_HelloMessage.BlockID() }
        set { _genesisBlockID = newValue }
    }

    /// Returns true if `genesisBlockID` has been explicitly set.
    var hasGenesisBlockID: Bool { _genesisBlockID != nil }
    /// Clears the value of `genesisBlockID`. Subsequent reads from it will return its default value.
    mutating func clearGenesisBlockID() { _genesisBlockID = nil }

    var solidBlockID: Protocol_HelloMessage.BlockID {
        get { _solidBlockID ?? Protocol_HelloMessage.BlockID() }
        set { _solidBlockID = newValue }
    }

    /// Returns true if `solidBlockID` has been explicitly set.
    var hasSolidBlockID: Bool { _solidBlockID != nil }
    /// Clears the value of `solidBlockID`. Subsequent reads from it will return its default value.
    mutating func clearSolidBlockID() { _solidBlockID = nil }

    var headBlockID: Protocol_HelloMessage.BlockID {
        get { _headBlockID ?? Protocol_HelloMessage.BlockID() }
        set { _headBlockID = newValue }
    }

    /// Returns true if `headBlockID` has been explicitly set.
    var hasHeadBlockID: Bool { _headBlockID != nil }
    /// Clears the value of `headBlockID`. Subsequent reads from it will return its default value.
    mutating func clearHeadBlockID() { _headBlockID = nil }

    var address: Data = .init()

    var signature: Data = .init()

    var nodeType: Int32 = 0

    var lowestBlockNum: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct BlockID {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var hash: Data = .init()

        var number: Int64 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() { }
    }

    init() { }

    private var _from: Protocol_Endpoint? = nil
    private var _genesisBlockID: Protocol_HelloMessage.BlockID? = nil
    private var _solidBlockID: Protocol_HelloMessage.BlockID? = nil
    private var _headBlockID: Protocol_HelloMessage.BlockID? = nil
}

// MARK: - Protocol_InternalTransaction

struct Protocol_InternalTransaction {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// internalTransaction identity, the root InternalTransaction hash
    /// should equals to root transaction id.
    var hash: Data = .init()

    /// the one send trx (TBD: or token) via function
    var callerAddress: Data = .init()

    /// the one recieve trx (TBD: or token) via function
    var transferToAddress: Data = .init()

    var callValueInfo: [Protocol_InternalTransaction.CallValueInfo] = []

    var note: Data = .init()

    var rejected = false

    var extra: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct CallValueInfo {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// trx (TBD: or token) value
        var callValue: Int64 = 0

        /// TBD: tokenName, trx should be empty
        var tokenID: String = .init()

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() { }
    }

    init() { }
}

// MARK: - Protocol_DelegatedResourceAccountIndex

struct Protocol_DelegatedResourceAccountIndex {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var account: Data = .init()

    var fromAccounts: [Data] = []

    var toAccounts: [Data] = []

    var timestamp: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_NodeInfo

struct Protocol_NodeInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var beginSyncNum: Int64 {
        get { _storage._beginSyncNum }
        set { _uniqueStorage()._beginSyncNum = newValue }
    }

    var block: String {
        get { _storage._block }
        set { _uniqueStorage()._block = newValue }
    }

    var solidityBlock: String {
        get { _storage._solidityBlock }
        set { _uniqueStorage()._solidityBlock = newValue }
    }

    /// connect information
    var currentConnectCount: Int32 {
        get { _storage._currentConnectCount }
        set { _uniqueStorage()._currentConnectCount = newValue }
    }

    var activeConnectCount: Int32 {
        get { _storage._activeConnectCount }
        set { _uniqueStorage()._activeConnectCount = newValue }
    }

    var passiveConnectCount: Int32 {
        get { _storage._passiveConnectCount }
        set { _uniqueStorage()._passiveConnectCount = newValue }
    }

    var totalFlow: Int64 {
        get { _storage._totalFlow }
        set { _uniqueStorage()._totalFlow = newValue }
    }

    var peerInfoList: [Protocol_NodeInfo.PeerInfo] {
        get { _storage._peerInfoList }
        set { _uniqueStorage()._peerInfoList = newValue }
    }

    var configNodeInfo: Protocol_NodeInfo.ConfigNodeInfo {
        get { _storage._configNodeInfo ?? Protocol_NodeInfo.ConfigNodeInfo() }
        set { _uniqueStorage()._configNodeInfo = newValue }
    }

    /// Returns true if `configNodeInfo` has been explicitly set.
    var hasConfigNodeInfo: Bool { _storage._configNodeInfo != nil }
    /// Clears the value of `configNodeInfo`. Subsequent reads from it will return its default value.
    mutating func clearConfigNodeInfo() { _uniqueStorage()._configNodeInfo = nil }

    var machineInfo: Protocol_NodeInfo.MachineInfo {
        get { _storage._machineInfo ?? Protocol_NodeInfo.MachineInfo() }
        set { _uniqueStorage()._machineInfo = newValue }
    }

    /// Returns true if `machineInfo` has been explicitly set.
    var hasMachineInfo: Bool { _storage._machineInfo != nil }
    /// Clears the value of `machineInfo`. Subsequent reads from it will return its default value.
    mutating func clearMachineInfo() { _uniqueStorage()._machineInfo = nil }

    var cheatWitnessInfoMap: [String: String] {
        get { _storage._cheatWitnessInfoMap }
        set { _uniqueStorage()._cheatWitnessInfoMap = newValue }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct PeerInfo {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var lastSyncBlock: String {
            get { _storage._lastSyncBlock }
            set { _uniqueStorage()._lastSyncBlock = newValue }
        }

        var remainNum: Int64 {
            get { _storage._remainNum }
            set { _uniqueStorage()._remainNum = newValue }
        }

        var lastBlockUpdateTime: Int64 {
            get { _storage._lastBlockUpdateTime }
            set { _uniqueStorage()._lastBlockUpdateTime = newValue }
        }

        var syncFlag: Bool {
            get { _storage._syncFlag }
            set { _uniqueStorage()._syncFlag = newValue }
        }

        var headBlockTimeWeBothHave: Int64 {
            get { _storage._headBlockTimeWeBothHave }
            set { _uniqueStorage()._headBlockTimeWeBothHave = newValue }
        }

        var needSyncFromPeer: Bool {
            get { _storage._needSyncFromPeer }
            set { _uniqueStorage()._needSyncFromPeer = newValue }
        }

        var needSyncFromUs: Bool {
            get { _storage._needSyncFromUs }
            set { _uniqueStorage()._needSyncFromUs = newValue }
        }

        var host: String {
            get { _storage._host }
            set { _uniqueStorage()._host = newValue }
        }

        var port: Int32 {
            get { _storage._port }
            set { _uniqueStorage()._port = newValue }
        }

        var nodeID: String {
            get { _storage._nodeID }
            set { _uniqueStorage()._nodeID = newValue }
        }

        var connectTime: Int64 {
            get { _storage._connectTime }
            set { _uniqueStorage()._connectTime = newValue }
        }

        var avgLatency: Double {
            get { _storage._avgLatency }
            set { _uniqueStorage()._avgLatency = newValue }
        }

        var syncToFetchSize: Int32 {
            get { _storage._syncToFetchSize }
            set { _uniqueStorage()._syncToFetchSize = newValue }
        }

        var syncToFetchSizePeekNum: Int64 {
            get { _storage._syncToFetchSizePeekNum }
            set { _uniqueStorage()._syncToFetchSizePeekNum = newValue }
        }

        var syncBlockRequestedSize: Int32 {
            get { _storage._syncBlockRequestedSize }
            set { _uniqueStorage()._syncBlockRequestedSize = newValue }
        }

        var unFetchSynNum: Int64 {
            get { _storage._unFetchSynNum }
            set { _uniqueStorage()._unFetchSynNum = newValue }
        }

        var blockInPorcSize: Int32 {
            get { _storage._blockInPorcSize }
            set { _uniqueStorage()._blockInPorcSize = newValue }
        }

        var headBlockWeBothHave: String {
            get { _storage._headBlockWeBothHave }
            set { _uniqueStorage()._headBlockWeBothHave = newValue }
        }

        var isActive: Bool {
            get { _storage._isActive }
            set { _uniqueStorage()._isActive = newValue }
        }

        var score: Int32 {
            get { _storage._score }
            set { _uniqueStorage()._score = newValue }
        }

        var nodeCount: Int32 {
            get { _storage._nodeCount }
            set { _uniqueStorage()._nodeCount = newValue }
        }

        var inFlow: Int64 {
            get { _storage._inFlow }
            set { _uniqueStorage()._inFlow = newValue }
        }

        var disconnectTimes: Int32 {
            get { _storage._disconnectTimes }
            set { _uniqueStorage()._disconnectTimes = newValue }
        }

        var localDisconnectReason: String {
            get { _storage._localDisconnectReason }
            set { _uniqueStorage()._localDisconnectReason = newValue }
        }

        var remoteDisconnectReason: String {
            get { _storage._remoteDisconnectReason }
            set { _uniqueStorage()._remoteDisconnectReason = newValue }
        }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() { }

        fileprivate var _storage = _StorageClass.defaultInstance
    }

    struct ConfigNodeInfo {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var codeVersion: String {
            get { _storage._codeVersion }
            set { _uniqueStorage()._codeVersion = newValue }
        }

        var p2PVersion: String {
            get { _storage._p2PVersion }
            set { _uniqueStorage()._p2PVersion = newValue }
        }

        var listenPort: Int32 {
            get { _storage._listenPort }
            set { _uniqueStorage()._listenPort = newValue }
        }

        var discoverEnable: Bool {
            get { _storage._discoverEnable }
            set { _uniqueStorage()._discoverEnable = newValue }
        }

        var activeNodeSize: Int32 {
            get { _storage._activeNodeSize }
            set { _uniqueStorage()._activeNodeSize = newValue }
        }

        var passiveNodeSize: Int32 {
            get { _storage._passiveNodeSize }
            set { _uniqueStorage()._passiveNodeSize = newValue }
        }

        var sendNodeSize: Int32 {
            get { _storage._sendNodeSize }
            set { _uniqueStorage()._sendNodeSize = newValue }
        }

        var maxConnectCount: Int32 {
            get { _storage._maxConnectCount }
            set { _uniqueStorage()._maxConnectCount = newValue }
        }

        var sameIpMaxConnectCount: Int32 {
            get { _storage._sameIpMaxConnectCount }
            set { _uniqueStorage()._sameIpMaxConnectCount = newValue }
        }

        var backupListenPort: Int32 {
            get { _storage._backupListenPort }
            set { _uniqueStorage()._backupListenPort = newValue }
        }

        var backupMemberSize: Int32 {
            get { _storage._backupMemberSize }
            set { _uniqueStorage()._backupMemberSize = newValue }
        }

        var backupPriority: Int32 {
            get { _storage._backupPriority }
            set { _uniqueStorage()._backupPriority = newValue }
        }

        var dbVersion: Int32 {
            get { _storage._dbVersion }
            set { _uniqueStorage()._dbVersion = newValue }
        }

        var minParticipationRate: Int32 {
            get { _storage._minParticipationRate }
            set { _uniqueStorage()._minParticipationRate = newValue }
        }

        var supportConstant: Bool {
            get { _storage._supportConstant }
            set { _uniqueStorage()._supportConstant = newValue }
        }

        var minTimeRatio: Double {
            get { _storage._minTimeRatio }
            set { _uniqueStorage()._minTimeRatio = newValue }
        }

        var maxTimeRatio: Double {
            get { _storage._maxTimeRatio }
            set { _uniqueStorage()._maxTimeRatio = newValue }
        }

        var allowCreationOfContracts: Int64 {
            get { _storage._allowCreationOfContracts }
            set { _uniqueStorage()._allowCreationOfContracts = newValue }
        }

        var allowAdaptiveEnergy: Int64 {
            get { _storage._allowAdaptiveEnergy }
            set { _uniqueStorage()._allowAdaptiveEnergy = newValue }
        }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() { }

        fileprivate var _storage = _StorageClass.defaultInstance
    }

    struct MachineInfo {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var threadCount: Int32 = 0

        var deadLockThreadCount: Int32 = 0

        var cpuCount: Int32 = 0

        var totalMemory: Int64 = 0

        var freeMemory: Int64 = 0

        var cpuRate: Double = 0

        var javaVersion: String = .init()

        var osName: String = .init()

        var jvmTotalMemory: Int64 = 0

        var jvmFreeMemory: Int64 = 0

        var processCpuRate: Double = 0

        var memoryDescInfoList: [Protocol_NodeInfo.MachineInfo.MemoryDescInfo] = []

        var deadLockThreadInfoList: [Protocol_NodeInfo.MachineInfo.DeadLockThreadInfo] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        struct MemoryDescInfo {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var name: String = .init()

            var initSize: Int64 = 0

            var useSize: Int64 = 0

            var maxSize: Int64 = 0

            var useRate: Double = 0

            var unknownFields = SwiftProtobuf.UnknownStorage()

            init() { }
        }

        struct DeadLockThreadInfo {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var name: String = .init()

            var lockName: String = .init()

            var lockOwner: String = .init()

            var state: String = .init()

            var blockTime: Int64 = 0

            var waitTime: Int64 = 0

            var stackTrace: String = .init()

            var unknownFields = SwiftProtobuf.UnknownStorage()

            init() { }
        }

        init() { }
    }

    init() { }

    fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Protocol_MetricsInfo

struct Protocol_MetricsInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var interval: Int64 = 0

    var node: Protocol_MetricsInfo.NodeInfo {
        get { _node ?? Protocol_MetricsInfo.NodeInfo() }
        set { _node = newValue }
    }

    /// Returns true if `node` has been explicitly set.
    var hasNode: Bool { _node != nil }
    /// Clears the value of `node`. Subsequent reads from it will return its default value.
    mutating func clearNode() { _node = nil }

    var blockchain: Protocol_MetricsInfo.BlockChainInfo {
        get { _blockchain ?? Protocol_MetricsInfo.BlockChainInfo() }
        set { _blockchain = newValue }
    }

    /// Returns true if `blockchain` has been explicitly set.
    var hasBlockchain: Bool { _blockchain != nil }
    /// Clears the value of `blockchain`. Subsequent reads from it will return its default value.
    mutating func clearBlockchain() { _blockchain = nil }

    var net: Protocol_MetricsInfo.NetInfo {
        get { _net ?? Protocol_MetricsInfo.NetInfo() }
        set { _net = newValue }
    }

    /// Returns true if `net` has been explicitly set.
    var hasNet: Bool { _net != nil }
    /// Clears the value of `net`. Subsequent reads from it will return its default value.
    mutating func clearNet() { _net = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct NodeInfo {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var ip: String = .init()

        var nodeType: Int32 = 0

        var version: String = .init()

        var backupStatus: Int32 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() { }
    }

    struct BlockChainInfo {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var headBlockNum: Int64 {
            get { _storage._headBlockNum }
            set { _uniqueStorage()._headBlockNum = newValue }
        }

        var headBlockTimestamp: Int64 {
            get { _storage._headBlockTimestamp }
            set { _uniqueStorage()._headBlockTimestamp = newValue }
        }

        var headBlockHash: String {
            get { _storage._headBlockHash }
            set { _uniqueStorage()._headBlockHash = newValue }
        }

        var forkCount: Int32 {
            get { _storage._forkCount }
            set { _uniqueStorage()._forkCount = newValue }
        }

        var failForkCount: Int32 {
            get { _storage._failForkCount }
            set { _uniqueStorage()._failForkCount = newValue }
        }

        var blockProcessTime: Protocol_MetricsInfo.RateInfo {
            get { _storage._blockProcessTime ?? Protocol_MetricsInfo.RateInfo() }
            set { _uniqueStorage()._blockProcessTime = newValue }
        }

        /// Returns true if `blockProcessTime` has been explicitly set.
        var hasBlockProcessTime: Bool { _storage._blockProcessTime != nil }
        /// Clears the value of `blockProcessTime`. Subsequent reads from it will return its default value.
        mutating func clearBlockProcessTime() { _uniqueStorage()._blockProcessTime = nil }

        var tps: Protocol_MetricsInfo.RateInfo {
            get { _storage._tps ?? Protocol_MetricsInfo.RateInfo() }
            set { _uniqueStorage()._tps = newValue }
        }

        /// Returns true if `tps` has been explicitly set.
        var hasTps: Bool { _storage._tps != nil }
        /// Clears the value of `tps`. Subsequent reads from it will return its default value.
        mutating func clearTps() { _uniqueStorage()._tps = nil }

        var transactionCacheSize: Int32 {
            get { _storage._transactionCacheSize }
            set { _uniqueStorage()._transactionCacheSize = newValue }
        }

        var missedTransaction: Protocol_MetricsInfo.RateInfo {
            get { _storage._missedTransaction ?? Protocol_MetricsInfo.RateInfo() }
            set { _uniqueStorage()._missedTransaction = newValue }
        }

        /// Returns true if `missedTransaction` has been explicitly set.
        var hasMissedTransaction: Bool { _storage._missedTransaction != nil }
        /// Clears the value of `missedTransaction`. Subsequent reads from it will return its default value.
        mutating func clearMissedTransaction() { _uniqueStorage()._missedTransaction = nil }

        var witnesses: [Protocol_MetricsInfo.BlockChainInfo.Witness] {
            get { _storage._witnesses }
            set { _uniqueStorage()._witnesses = newValue }
        }

        var failProcessBlockNum: Int64 {
            get { _storage._failProcessBlockNum }
            set { _uniqueStorage()._failProcessBlockNum = newValue }
        }

        var failProcessBlockReason: String {
            get { _storage._failProcessBlockReason }
            set { _uniqueStorage()._failProcessBlockReason = newValue }
        }

        var dupWitness: [Protocol_MetricsInfo.BlockChainInfo.DupWitness] {
            get { _storage._dupWitness }
            set { _uniqueStorage()._dupWitness = newValue }
        }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        struct Witness {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var address: String = .init()

            var version: Int32 = 0

            var unknownFields = SwiftProtobuf.UnknownStorage()

            init() { }
        }

        struct DupWitness {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var address: String = .init()

            var blockNum: Int64 = 0

            var count: Int32 = 0

            var unknownFields = SwiftProtobuf.UnknownStorage()

            init() { }
        }

        init() { }

        fileprivate var _storage = _StorageClass.defaultInstance
    }

    struct RateInfo {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var count: Int64 = 0

        var meanRate: Double = 0

        var oneMinuteRate: Double = 0

        var fiveMinuteRate: Double = 0

        var fifteenMinuteRate: Double = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() { }
    }

    struct NetInfo {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var errorProtoCount: Int32 {
            get { _storage._errorProtoCount }
            set { _uniqueStorage()._errorProtoCount = newValue }
        }

        var api: Protocol_MetricsInfo.NetInfo.ApiInfo {
            get { _storage._api ?? Protocol_MetricsInfo.NetInfo.ApiInfo() }
            set { _uniqueStorage()._api = newValue }
        }

        /// Returns true if `api` has been explicitly set.
        var hasApi: Bool { _storage._api != nil }
        /// Clears the value of `api`. Subsequent reads from it will return its default value.
        mutating func clearApi() { _uniqueStorage()._api = nil }

        var connectionCount: Int32 {
            get { _storage._connectionCount }
            set { _uniqueStorage()._connectionCount = newValue }
        }

        var validConnectionCount: Int32 {
            get { _storage._validConnectionCount }
            set { _uniqueStorage()._validConnectionCount = newValue }
        }

        var tcpInTraffic: Protocol_MetricsInfo.RateInfo {
            get { _storage._tcpInTraffic ?? Protocol_MetricsInfo.RateInfo() }
            set { _uniqueStorage()._tcpInTraffic = newValue }
        }

        /// Returns true if `tcpInTraffic` has been explicitly set.
        var hasTcpInTraffic: Bool { _storage._tcpInTraffic != nil }
        /// Clears the value of `tcpInTraffic`. Subsequent reads from it will return its default value.
        mutating func clearTcpInTraffic() { _uniqueStorage()._tcpInTraffic = nil }

        var tcpOutTraffic: Protocol_MetricsInfo.RateInfo {
            get { _storage._tcpOutTraffic ?? Protocol_MetricsInfo.RateInfo() }
            set { _uniqueStorage()._tcpOutTraffic = newValue }
        }

        /// Returns true if `tcpOutTraffic` has been explicitly set.
        var hasTcpOutTraffic: Bool { _storage._tcpOutTraffic != nil }
        /// Clears the value of `tcpOutTraffic`. Subsequent reads from it will return its default value.
        mutating func clearTcpOutTraffic() { _uniqueStorage()._tcpOutTraffic = nil }

        var disconnectionCount: Int32 {
            get { _storage._disconnectionCount }
            set { _uniqueStorage()._disconnectionCount = newValue }
        }

        var disconnectionDetail: [Protocol_MetricsInfo.NetInfo.DisconnectionDetailInfo] {
            get { _storage._disconnectionDetail }
            set { _uniqueStorage()._disconnectionDetail = newValue }
        }

        var udpInTraffic: Protocol_MetricsInfo.RateInfo {
            get { _storage._udpInTraffic ?? Protocol_MetricsInfo.RateInfo() }
            set { _uniqueStorage()._udpInTraffic = newValue }
        }

        /// Returns true if `udpInTraffic` has been explicitly set.
        var hasUdpInTraffic: Bool { _storage._udpInTraffic != nil }
        /// Clears the value of `udpInTraffic`. Subsequent reads from it will return its default value.
        mutating func clearUdpInTraffic() { _uniqueStorage()._udpInTraffic = nil }

        var udpOutTraffic: Protocol_MetricsInfo.RateInfo {
            get { _storage._udpOutTraffic ?? Protocol_MetricsInfo.RateInfo() }
            set { _uniqueStorage()._udpOutTraffic = newValue }
        }

        /// Returns true if `udpOutTraffic` has been explicitly set.
        var hasUdpOutTraffic: Bool { _storage._udpOutTraffic != nil }
        /// Clears the value of `udpOutTraffic`. Subsequent reads from it will return its default value.
        mutating func clearUdpOutTraffic() { _uniqueStorage()._udpOutTraffic = nil }

        var latency: Protocol_MetricsInfo.NetInfo.LatencyInfo {
            get { _storage._latency ?? Protocol_MetricsInfo.NetInfo.LatencyInfo() }
            set { _uniqueStorage()._latency = newValue }
        }

        /// Returns true if `latency` has been explicitly set.
        var hasLatency: Bool { _storage._latency != nil }
        /// Clears the value of `latency`. Subsequent reads from it will return its default value.
        mutating func clearLatency() { _uniqueStorage()._latency = nil }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        struct ApiInfo {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var qps: Protocol_MetricsInfo.RateInfo {
                get { _qps ?? Protocol_MetricsInfo.RateInfo() }
                set { _qps = newValue }
            }

            /// Returns true if `qps` has been explicitly set.
            var hasQps: Bool { _qps != nil }
            /// Clears the value of `qps`. Subsequent reads from it will return its default value.
            mutating func clearQps() { _qps = nil }

            var failQps: Protocol_MetricsInfo.RateInfo {
                get { _failQps ?? Protocol_MetricsInfo.RateInfo() }
                set { _failQps = newValue }
            }

            /// Returns true if `failQps` has been explicitly set.
            var hasFailQps: Bool { _failQps != nil }
            /// Clears the value of `failQps`. Subsequent reads from it will return its default value.
            mutating func clearFailQps() { _failQps = nil }

            var outTraffic: Protocol_MetricsInfo.RateInfo {
                get { _outTraffic ?? Protocol_MetricsInfo.RateInfo() }
                set { _outTraffic = newValue }
            }

            /// Returns true if `outTraffic` has been explicitly set.
            var hasOutTraffic: Bool { _outTraffic != nil }
            /// Clears the value of `outTraffic`. Subsequent reads from it will return its default value.
            mutating func clearOutTraffic() { _outTraffic = nil }

            var detail: [Protocol_MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo] = []

            var unknownFields = SwiftProtobuf.UnknownStorage()

            struct ApiDetailInfo {
                // SwiftProtobuf.Message conformance is added in an extension below. See the
                // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
                // methods supported on all messages.

                var name: String = .init()

                var qps: Protocol_MetricsInfo.RateInfo {
                    get { _qps ?? Protocol_MetricsInfo.RateInfo() }
                    set { _qps = newValue }
                }

                /// Returns true if `qps` has been explicitly set.
                var hasQps: Bool { _qps != nil }
                /// Clears the value of `qps`. Subsequent reads from it will return its default value.
                mutating func clearQps() { _qps = nil }

                var failQps: Protocol_MetricsInfo.RateInfo {
                    get { _failQps ?? Protocol_MetricsInfo.RateInfo() }
                    set { _failQps = newValue }
                }

                /// Returns true if `failQps` has been explicitly set.
                var hasFailQps: Bool { _failQps != nil }
                /// Clears the value of `failQps`. Subsequent reads from it will return its default value.
                mutating func clearFailQps() { _failQps = nil }

                var outTraffic: Protocol_MetricsInfo.RateInfo {
                    get { _outTraffic ?? Protocol_MetricsInfo.RateInfo() }
                    set { _outTraffic = newValue }
                }

                /// Returns true if `outTraffic` has been explicitly set.
                var hasOutTraffic: Bool { _outTraffic != nil }
                /// Clears the value of `outTraffic`. Subsequent reads from it will return its default value.
                mutating func clearOutTraffic() { _outTraffic = nil }

                var unknownFields = SwiftProtobuf.UnknownStorage()

                init() { }

                fileprivate var _qps: Protocol_MetricsInfo.RateInfo? = nil
                fileprivate var _failQps: Protocol_MetricsInfo.RateInfo? = nil
                fileprivate var _outTraffic: Protocol_MetricsInfo.RateInfo? = nil
            }

            init() { }

            fileprivate var _qps: Protocol_MetricsInfo.RateInfo? = nil
            fileprivate var _failQps: Protocol_MetricsInfo.RateInfo? = nil
            fileprivate var _outTraffic: Protocol_MetricsInfo.RateInfo? = nil
        }

        struct DisconnectionDetailInfo {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var reason: String = .init()

            var count: Int32 = 0

            var unknownFields = SwiftProtobuf.UnknownStorage()

            init() { }
        }

        struct LatencyInfo {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var top99: Int32 = 0

            var top95: Int32 = 0

            var top75: Int32 = 0

            var totalCount: Int32 = 0

            var delay1S: Int32 = 0

            var delay2S: Int32 = 0

            var delay3S: Int32 = 0

            var detail: [Protocol_MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo] = []

            var unknownFields = SwiftProtobuf.UnknownStorage()

            struct LatencyDetailInfo {
                // SwiftProtobuf.Message conformance is added in an extension below. See the
                // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
                // methods supported on all messages.

                var witness: String = .init()

                var top99: Int32 = 0

                var top95: Int32 = 0

                var top75: Int32 = 0

                var count: Int32 = 0

                var delay1S: Int32 = 0

                var delay2S: Int32 = 0

                var delay3S: Int32 = 0

                var unknownFields = SwiftProtobuf.UnknownStorage()

                init() { }
            }

            init() { }
        }

        init() { }

        fileprivate var _storage = _StorageClass.defaultInstance
    }

    init() { }

    private var _node: Protocol_MetricsInfo.NodeInfo? = nil
    private var _blockchain: Protocol_MetricsInfo.BlockChainInfo? = nil
    private var _net: Protocol_MetricsInfo.NetInfo? = nil
}

// MARK: - Protocol_PBFTMessage

struct Protocol_PBFTMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rawData: Protocol_PBFTMessage.Raw {
        get { _rawData ?? Protocol_PBFTMessage.Raw() }
        set { _rawData = newValue }
    }

    /// Returns true if `rawData` has been explicitly set.
    var hasRawData: Bool { _rawData != nil }
    /// Clears the value of `rawData`. Subsequent reads from it will return its default value.
    mutating func clearRawData() { _rawData = nil }

    var signature: Data = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum MsgType: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case viewChange // = 0
        case request // = 1
        case preprepare // = 2
        case prepare // = 3
        case commit // = 4
        case UNRECOGNIZED(Int)

        init() {
            self = .viewChange
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .viewChange
            case 1: self = .request
            case 2: self = .preprepare
            case 3: self = .prepare
            case 4: self = .commit
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .viewChange: 0
            case .request: 1
            case .preprepare: 2
            case .prepare: 3
            case .commit: 4
            case .UNRECOGNIZED(let i): i
            }
        }
    }

    enum DataType: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case block // = 0
        case srl // = 1
        case UNRECOGNIZED(Int)

        init() {
            self = .block
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .block
            case 1: self = .srl
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .block: 0
            case .srl: 1
            case .UNRECOGNIZED(let i): i
            }
        }
    }

    struct Raw {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var msgType: Protocol_PBFTMessage.MsgType = .viewChange

        var dataType: Protocol_PBFTMessage.DataType = .block

        var viewN: Int64 = 0

        var epoch: Int64 = 0

        var data: Data = .init()

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() { }
    }

    init() { }

    fileprivate var _rawData: Protocol_PBFTMessage.Raw? = nil
}

#if swift(>=4.2)

extension Protocol_PBFTMessage.MsgType: CaseIterable {
    /// The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Protocol_PBFTMessage.MsgType] = [
        .viewChange,
        .request,
        .preprepare,
        .prepare,
        .commit,
    ]
}

extension Protocol_PBFTMessage.DataType: CaseIterable {
    /// The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Protocol_PBFTMessage.DataType] = [
        .block,
        .srl,
    ]
}

#endif // swift(>=4.2)

// MARK: - Protocol_PBFTCommitResult

struct Protocol_PBFTCommitResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var data: Data = .init()

    var signature: [Data] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

// MARK: - Protocol_SRL

struct Protocol_SRL {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var srAddress: [Data] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() { }
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Protocol_AccountType: @unchecked Sendable { }
extension Protocol_ReasonCode: @unchecked Sendable { }
extension Protocol_AccountID: @unchecked Sendable { }
extension Protocol_Vote: @unchecked Sendable { }
extension Protocol_Proposal: @unchecked Sendable { }
extension Protocol_Proposal.State: @unchecked Sendable { }
extension Protocol_Exchange: @unchecked Sendable { }
extension Protocol_MarketOrder: @unchecked Sendable { }
extension Protocol_MarketOrder.State: @unchecked Sendable { }
extension Protocol_MarketOrderList: @unchecked Sendable { }
extension Protocol_MarketOrderPairList: @unchecked Sendable { }
extension Protocol_MarketOrderPair: @unchecked Sendable { }
extension Protocol_MarketAccountOrder: @unchecked Sendable { }
extension Protocol_MarketPrice: @unchecked Sendable { }
extension Protocol_MarketPriceList: @unchecked Sendable { }
extension Protocol_MarketOrderIDList: @unchecked Sendable { }
extension Protocol_ChainParameters: @unchecked Sendable { }
extension Protocol_ChainParameters.ChainParameter: @unchecked Sendable { }
extension Protocol_Account: @unchecked Sendable { }
extension Protocol_Account.Frozen: @unchecked Sendable { }
extension Protocol_Account.AccountResource: @unchecked Sendable { }
extension Protocol_Account.FreezeV2: @unchecked Sendable { }
extension Protocol_Account.UnFreezeV2: @unchecked Sendable { }
extension Protocol_Key: @unchecked Sendable { }
extension Protocol_DelegatedResource: @unchecked Sendable { }
extension Protocol_authority: @unchecked Sendable { }
extension Protocol_Permission: @unchecked Sendable { }
extension Protocol_Permission.PermissionType: @unchecked Sendable { }
extension Protocol_Witness: @unchecked Sendable { }
extension Protocol_Votes: @unchecked Sendable { }
extension Protocol_TXOutput: @unchecked Sendable { }
extension Protocol_TXInput: @unchecked Sendable { }
extension Protocol_TXInput.raw: @unchecked Sendable { }
extension Protocol_TXOutputs: @unchecked Sendable { }
extension Protocol_ResourceReceipt: @unchecked Sendable { }
extension Protocol_MarketOrderDetail: @unchecked Sendable { }
extension Protocol_Transaction: @unchecked Sendable { }
extension Protocol_Transaction.Contract: @unchecked Sendable { }
extension Protocol_Transaction.Contract.ContractType: @unchecked Sendable { }
extension Protocol_Transaction.Result: @unchecked Sendable { }
extension Protocol_Transaction.Result.code: @unchecked Sendable { }
extension Protocol_Transaction.Result.contractResult: @unchecked Sendable { }
extension Protocol_Transaction.raw: @unchecked Sendable { }
extension Protocol_TransactionInfo: @unchecked Sendable { }
extension Protocol_TransactionInfo.code: @unchecked Sendable { }
extension Protocol_TransactionInfo.Log: @unchecked Sendable { }
extension Protocol_TransactionRet: @unchecked Sendable { }
extension Protocol_Transactions: @unchecked Sendable { }
extension Protocol_BlockHeader: @unchecked Sendable { }
extension Protocol_BlockHeader.raw: @unchecked Sendable { }
extension Protocol_Block: @unchecked Sendable { }
extension Protocol_ChainInventory: @unchecked Sendable { }
extension Protocol_ChainInventory.BlockID: @unchecked Sendable { }
extension Protocol_BlockInventory: @unchecked Sendable { }
extension Protocol_BlockInventory.TypeEnum: @unchecked Sendable { }
extension Protocol_BlockInventory.BlockID: @unchecked Sendable { }
extension Protocol_Inventory: @unchecked Sendable { }
extension Protocol_Inventory.InventoryType: @unchecked Sendable { }
extension Protocol_Items: @unchecked Sendable { }
extension Protocol_Items.ItemType: @unchecked Sendable { }
extension Protocol_DynamicProperties: @unchecked Sendable { }
extension Protocol_DisconnectMessage: @unchecked Sendable { }
extension Protocol_HelloMessage: @unchecked Sendable { }
extension Protocol_HelloMessage.BlockID: @unchecked Sendable { }
extension Protocol_InternalTransaction: @unchecked Sendable { }
extension Protocol_InternalTransaction.CallValueInfo: @unchecked Sendable { }
extension Protocol_DelegatedResourceAccountIndex: @unchecked Sendable { }
extension Protocol_NodeInfo: @unchecked Sendable { }
extension Protocol_NodeInfo.PeerInfo: @unchecked Sendable { }
extension Protocol_NodeInfo.ConfigNodeInfo: @unchecked Sendable { }
extension Protocol_NodeInfo.MachineInfo: @unchecked Sendable { }
extension Protocol_NodeInfo.MachineInfo.MemoryDescInfo: @unchecked Sendable { }
extension Protocol_NodeInfo.MachineInfo.DeadLockThreadInfo: @unchecked Sendable { }
extension Protocol_MetricsInfo: @unchecked Sendable { }
extension Protocol_MetricsInfo.NodeInfo: @unchecked Sendable { }
extension Protocol_MetricsInfo.BlockChainInfo: @unchecked Sendable { }
extension Protocol_MetricsInfo.BlockChainInfo.Witness: @unchecked Sendable { }
extension Protocol_MetricsInfo.BlockChainInfo.DupWitness: @unchecked Sendable { }
extension Protocol_MetricsInfo.RateInfo: @unchecked Sendable { }
extension Protocol_MetricsInfo.NetInfo: @unchecked Sendable { }
extension Protocol_MetricsInfo.NetInfo.ApiInfo: @unchecked Sendable { }
extension Protocol_MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo: @unchecked Sendable { }
extension Protocol_MetricsInfo.NetInfo.DisconnectionDetailInfo: @unchecked Sendable { }
extension Protocol_MetricsInfo.NetInfo.LatencyInfo: @unchecked Sendable { }
extension Protocol_MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo: @unchecked Sendable { }
extension Protocol_PBFTMessage: @unchecked Sendable { }
extension Protocol_PBFTMessage.MsgType: @unchecked Sendable { }
extension Protocol_PBFTMessage.DataType: @unchecked Sendable { }
extension Protocol_PBFTMessage.Raw: @unchecked Sendable { }
extension Protocol_PBFTCommitResult: @unchecked Sendable { }
extension Protocol_SRL: @unchecked Sendable { }
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "protocol"

// MARK: - Protocol_AccountType + SwiftProtobuf._ProtoNameProviding

extension Protocol_AccountType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Normal"),
        1: .same(proto: "AssetIssue"),
        2: .same(proto: "Contract"),
    ]
}

// MARK: - Protocol_ReasonCode + SwiftProtobuf._ProtoNameProviding

extension Protocol_ReasonCode: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "REQUESTED"),
        2: .same(proto: "BAD_PROTOCOL"),
        4: .same(proto: "TOO_MANY_PEERS"),
        5: .same(proto: "DUPLICATE_PEER"),
        6: .same(proto: "INCOMPATIBLE_PROTOCOL"),
        7: .same(proto: "RANDOM_ELIMINATION"),
        8: .same(proto: "PEER_QUITING"),
        9: .same(proto: "UNEXPECTED_IDENTITY"),
        10: .same(proto: "LOCAL_IDENTITY"),
        11: .same(proto: "PING_TIMEOUT"),
        16: .same(proto: "USER_REASON"),
        17: .same(proto: "RESET"),
        18: .same(proto: "SYNC_FAIL"),
        19: .same(proto: "FETCH_FAIL"),
        20: .same(proto: "BAD_TX"),
        21: .same(proto: "BAD_BLOCK"),
        22: .same(proto: "FORKED"),
        23: .same(proto: "UNLINKABLE"),
        24: .same(proto: "INCOMPATIBLE_VERSION"),
        25: .same(proto: "INCOMPATIBLE_CHAIN"),
        32: .same(proto: "TIME_OUT"),
        33: .same(proto: "CONNECT_FAIL"),
        34: .same(proto: "TOO_MANY_PEERS_WITH_SAME_IP"),
        35: .same(proto: "LIGHT_NODE_SYNC_FAIL"),
        255: .same(proto: "UNKNOWN"),
    ]
}

// MARK: - Protocol_AccountID + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_AccountID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AccountId"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .same(proto: "address"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &name)
            case 2: try decoder.decodeSingularBytesField(value: &address)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularBytesField(value: name, fieldNumber: 1)
        }
        if !address.isEmpty {
            try visitor.visitSingularBytesField(value: address, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_AccountID, rhs: Protocol_AccountID) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.address != rhs.address { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Vote + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_Vote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Vote"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "vote_address"),
        2: .standard(proto: "vote_count"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &voteAddress)
            case 2: try decoder.decodeSingularInt64Field(value: &voteCount)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !voteAddress.isEmpty {
            try visitor.visitSingularBytesField(value: voteAddress, fieldNumber: 1)
        }
        if voteCount != 0 {
            try visitor.visitSingularInt64Field(value: voteCount, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_Vote, rhs: Protocol_Vote) -> Bool {
        if lhs.voteAddress != rhs.voteAddress { return false }
        if lhs.voteCount != rhs.voteCount { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Proposal + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_Proposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Proposal"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "proposal_id"),
        2: .standard(proto: "proposer_address"),
        3: .same(proto: "parameters"),
        4: .standard(proto: "expiration_time"),
        5: .standard(proto: "create_time"),
        6: .same(proto: "approvals"),
        7: .same(proto: "state"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &proposalID)

            case 2: try decoder.decodeSingularBytesField(value: &proposerAddress)

            case 3: try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64, SwiftProtobuf.ProtobufInt64>.self,
                    value: &parameters
                )

            case 4: try decoder.decodeSingularInt64Field(value: &expirationTime)

            case 5: try decoder.decodeSingularInt64Field(value: &createTime)

            case 6: try decoder.decodeRepeatedBytesField(value: &approvals)

            case 7: try decoder.decodeSingularEnumField(value: &state)

            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if proposalID != 0 {
            try visitor.visitSingularInt64Field(value: proposalID, fieldNumber: 1)
        }
        if !proposerAddress.isEmpty {
            try visitor.visitSingularBytesField(value: proposerAddress, fieldNumber: 2)
        }
        if !parameters.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64, SwiftProtobuf.ProtobufInt64>.self,
                value: parameters,
                fieldNumber: 3
            )
        }
        if expirationTime != 0 {
            try visitor.visitSingularInt64Field(value: expirationTime, fieldNumber: 4)
        }
        if createTime != 0 {
            try visitor.visitSingularInt64Field(value: createTime, fieldNumber: 5)
        }
        if !approvals.isEmpty {
            try visitor.visitRepeatedBytesField(value: approvals, fieldNumber: 6)
        }
        if state != .pending {
            try visitor.visitSingularEnumField(value: state, fieldNumber: 7)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_Proposal, rhs: Protocol_Proposal) -> Bool {
        if lhs.proposalID != rhs.proposalID { return false }
        if lhs.proposerAddress != rhs.proposerAddress { return false }
        if lhs.parameters != rhs.parameters { return false }
        if lhs.expirationTime != rhs.expirationTime { return false }
        if lhs.createTime != rhs.createTime { return false }
        if lhs.approvals != rhs.approvals { return false }
        if lhs.state != rhs.state { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Proposal.State + SwiftProtobuf._ProtoNameProviding

extension Protocol_Proposal.State: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "PENDING"),
        1: .same(proto: "DISAPPROVED"),
        2: .same(proto: "APPROVED"),
        3: .same(proto: "CANCELED"),
    ]
}

// MARK: - Protocol_Exchange + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_Exchange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Exchange"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "exchange_id"),
        2: .standard(proto: "creator_address"),
        3: .standard(proto: "create_time"),
        6: .standard(proto: "first_token_id"),
        7: .standard(proto: "first_token_balance"),
        8: .standard(proto: "second_token_id"),
        9: .standard(proto: "second_token_balance"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &exchangeID)
            case 2: try decoder.decodeSingularBytesField(value: &creatorAddress)
            case 3: try decoder.decodeSingularInt64Field(value: &createTime)
            case 6: try decoder.decodeSingularBytesField(value: &firstTokenID)
            case 7: try decoder.decodeSingularInt64Field(value: &firstTokenBalance)
            case 8: try decoder.decodeSingularBytesField(value: &secondTokenID)
            case 9: try decoder.decodeSingularInt64Field(value: &secondTokenBalance)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if exchangeID != 0 {
            try visitor.visitSingularInt64Field(value: exchangeID, fieldNumber: 1)
        }
        if !creatorAddress.isEmpty {
            try visitor.visitSingularBytesField(value: creatorAddress, fieldNumber: 2)
        }
        if createTime != 0 {
            try visitor.visitSingularInt64Field(value: createTime, fieldNumber: 3)
        }
        if !firstTokenID.isEmpty {
            try visitor.visitSingularBytesField(value: firstTokenID, fieldNumber: 6)
        }
        if firstTokenBalance != 0 {
            try visitor.visitSingularInt64Field(value: firstTokenBalance, fieldNumber: 7)
        }
        if !secondTokenID.isEmpty {
            try visitor.visitSingularBytesField(value: secondTokenID, fieldNumber: 8)
        }
        if secondTokenBalance != 0 {
            try visitor.visitSingularInt64Field(value: secondTokenBalance, fieldNumber: 9)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_Exchange, rhs: Protocol_Exchange) -> Bool {
        if lhs.exchangeID != rhs.exchangeID { return false }
        if lhs.creatorAddress != rhs.creatorAddress { return false }
        if lhs.createTime != rhs.createTime { return false }
        if lhs.firstTokenID != rhs.firstTokenID { return false }
        if lhs.firstTokenBalance != rhs.firstTokenBalance { return false }
        if lhs.secondTokenID != rhs.secondTokenID { return false }
        if lhs.secondTokenBalance != rhs.secondTokenBalance { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MarketOrder + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MarketOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".MarketOrder"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "order_id"),
        2: .standard(proto: "owner_address"),
        3: .standard(proto: "create_time"),
        4: .standard(proto: "sell_token_id"),
        5: .standard(proto: "sell_token_quantity"),
        6: .standard(proto: "buy_token_id"),
        7: .standard(proto: "buy_token_quantity"),
        9: .standard(proto: "sell_token_quantity_remain"),
        10: .standard(proto: "sell_token_quantity_return"),
        11: .same(proto: "state"),
        12: .same(proto: "prev"),
        13: .same(proto: "next"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &orderID)
            case 2: try decoder.decodeSingularBytesField(value: &ownerAddress)
            case 3: try decoder.decodeSingularInt64Field(value: &createTime)
            case 4: try decoder.decodeSingularBytesField(value: &sellTokenID)
            case 5: try decoder.decodeSingularInt64Field(value: &sellTokenQuantity)
            case 6: try decoder.decodeSingularBytesField(value: &buyTokenID)
            case 7: try decoder.decodeSingularInt64Field(value: &buyTokenQuantity)
            case 9: try decoder.decodeSingularInt64Field(value: &sellTokenQuantityRemain)
            case 10: try decoder.decodeSingularInt64Field(value: &sellTokenQuantityReturn)
            case 11: try decoder.decodeSingularEnumField(value: &state)
            case 12: try decoder.decodeSingularBytesField(value: &prev)
            case 13: try decoder.decodeSingularBytesField(value: &next)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !orderID.isEmpty {
            try visitor.visitSingularBytesField(value: orderID, fieldNumber: 1)
        }
        if !ownerAddress.isEmpty {
            try visitor.visitSingularBytesField(value: ownerAddress, fieldNumber: 2)
        }
        if createTime != 0 {
            try visitor.visitSingularInt64Field(value: createTime, fieldNumber: 3)
        }
        if !sellTokenID.isEmpty {
            try visitor.visitSingularBytesField(value: sellTokenID, fieldNumber: 4)
        }
        if sellTokenQuantity != 0 {
            try visitor.visitSingularInt64Field(value: sellTokenQuantity, fieldNumber: 5)
        }
        if !buyTokenID.isEmpty {
            try visitor.visitSingularBytesField(value: buyTokenID, fieldNumber: 6)
        }
        if buyTokenQuantity != 0 {
            try visitor.visitSingularInt64Field(value: buyTokenQuantity, fieldNumber: 7)
        }
        if sellTokenQuantityRemain != 0 {
            try visitor.visitSingularInt64Field(value: sellTokenQuantityRemain, fieldNumber: 9)
        }
        if sellTokenQuantityReturn != 0 {
            try visitor.visitSingularInt64Field(value: sellTokenQuantityReturn, fieldNumber: 10)
        }
        if state != .active {
            try visitor.visitSingularEnumField(value: state, fieldNumber: 11)
        }
        if !prev.isEmpty {
            try visitor.visitSingularBytesField(value: prev, fieldNumber: 12)
        }
        if !next.isEmpty {
            try visitor.visitSingularBytesField(value: next, fieldNumber: 13)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_MarketOrder, rhs: Protocol_MarketOrder) -> Bool {
        if lhs.orderID != rhs.orderID { return false }
        if lhs.ownerAddress != rhs.ownerAddress { return false }
        if lhs.createTime != rhs.createTime { return false }
        if lhs.sellTokenID != rhs.sellTokenID { return false }
        if lhs.sellTokenQuantity != rhs.sellTokenQuantity { return false }
        if lhs.buyTokenID != rhs.buyTokenID { return false }
        if lhs.buyTokenQuantity != rhs.buyTokenQuantity { return false }
        if lhs.sellTokenQuantityRemain != rhs.sellTokenQuantityRemain { return false }
        if lhs.sellTokenQuantityReturn != rhs.sellTokenQuantityReturn { return false }
        if lhs.state != rhs.state { return false }
        if lhs.prev != rhs.prev { return false }
        if lhs.next != rhs.next { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MarketOrder.State + SwiftProtobuf._ProtoNameProviding

extension Protocol_MarketOrder.State: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "ACTIVE"),
        1: .same(proto: "INACTIVE"),
        2: .same(proto: "CANCELED"),
    ]
}

// MARK: - Protocol_MarketOrderList + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MarketOrderList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".MarketOrderList"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "orders"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &orders)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !orders.isEmpty {
            try visitor.visitRepeatedMessageField(value: orders, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_MarketOrderList, rhs: Protocol_MarketOrderList) -> Bool {
        if lhs.orders != rhs.orders { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MarketOrderPairList + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MarketOrderPairList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".MarketOrderPairList"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "orderPair"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &orderPair)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !orderPair.isEmpty {
            try visitor.visitRepeatedMessageField(value: orderPair, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_MarketOrderPairList, rhs: Protocol_MarketOrderPairList) -> Bool {
        if lhs.orderPair != rhs.orderPair { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MarketOrderPair + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MarketOrderPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".MarketOrderPair"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "sell_token_id"),
        2: .standard(proto: "buy_token_id"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &sellTokenID)
            case 2: try decoder.decodeSingularBytesField(value: &buyTokenID)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !sellTokenID.isEmpty {
            try visitor.visitSingularBytesField(value: sellTokenID, fieldNumber: 1)
        }
        if !buyTokenID.isEmpty {
            try visitor.visitSingularBytesField(value: buyTokenID, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_MarketOrderPair, rhs: Protocol_MarketOrderPair) -> Bool {
        if lhs.sellTokenID != rhs.sellTokenID { return false }
        if lhs.buyTokenID != rhs.buyTokenID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MarketAccountOrder + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MarketAccountOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".MarketAccountOrder"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "owner_address"),
        2: .same(proto: "orders"),
        3: .same(proto: "count"),
        4: .standard(proto: "total_count"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &ownerAddress)
            case 2: try decoder.decodeRepeatedBytesField(value: &orders)
            case 3: try decoder.decodeSingularInt64Field(value: &count)
            case 4: try decoder.decodeSingularInt64Field(value: &totalCount)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !ownerAddress.isEmpty {
            try visitor.visitSingularBytesField(value: ownerAddress, fieldNumber: 1)
        }
        if !orders.isEmpty {
            try visitor.visitRepeatedBytesField(value: orders, fieldNumber: 2)
        }
        if count != 0 {
            try visitor.visitSingularInt64Field(value: count, fieldNumber: 3)
        }
        if totalCount != 0 {
            try visitor.visitSingularInt64Field(value: totalCount, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_MarketAccountOrder, rhs: Protocol_MarketAccountOrder) -> Bool {
        if lhs.ownerAddress != rhs.ownerAddress { return false }
        if lhs.orders != rhs.orders { return false }
        if lhs.count != rhs.count { return false }
        if lhs.totalCount != rhs.totalCount { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MarketPrice + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MarketPrice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".MarketPrice"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "sell_token_quantity"),
        2: .standard(proto: "buy_token_quantity"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &sellTokenQuantity)
            case 2: try decoder.decodeSingularInt64Field(value: &buyTokenQuantity)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if sellTokenQuantity != 0 {
            try visitor.visitSingularInt64Field(value: sellTokenQuantity, fieldNumber: 1)
        }
        if buyTokenQuantity != 0 {
            try visitor.visitSingularInt64Field(value: buyTokenQuantity, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_MarketPrice, rhs: Protocol_MarketPrice) -> Bool {
        if lhs.sellTokenQuantity != rhs.sellTokenQuantity { return false }
        if lhs.buyTokenQuantity != rhs.buyTokenQuantity { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MarketPriceList + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MarketPriceList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".MarketPriceList"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "sell_token_id"),
        2: .standard(proto: "buy_token_id"),
        3: .same(proto: "prices"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &sellTokenID)
            case 2: try decoder.decodeSingularBytesField(value: &buyTokenID)
            case 3: try decoder.decodeRepeatedMessageField(value: &prices)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !sellTokenID.isEmpty {
            try visitor.visitSingularBytesField(value: sellTokenID, fieldNumber: 1)
        }
        if !buyTokenID.isEmpty {
            try visitor.visitSingularBytesField(value: buyTokenID, fieldNumber: 2)
        }
        if !prices.isEmpty {
            try visitor.visitRepeatedMessageField(value: prices, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_MarketPriceList, rhs: Protocol_MarketPriceList) -> Bool {
        if lhs.sellTokenID != rhs.sellTokenID { return false }
        if lhs.buyTokenID != rhs.buyTokenID { return false }
        if lhs.prices != rhs.prices { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MarketOrderIDList + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MarketOrderIDList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".MarketOrderIdList"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "head"),
        2: .same(proto: "tail"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &head)
            case 2: try decoder.decodeSingularBytesField(value: &tail)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !head.isEmpty {
            try visitor.visitSingularBytesField(value: head, fieldNumber: 1)
        }
        if !tail.isEmpty {
            try visitor.visitSingularBytesField(value: tail, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_MarketOrderIDList, rhs: Protocol_MarketOrderIDList) -> Bool {
        if lhs.head != rhs.head { return false }
        if lhs.tail != rhs.tail { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_ChainParameters + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_ChainParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".ChainParameters"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "chainParameter"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &chainParameter)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !chainParameter.isEmpty {
            try visitor.visitRepeatedMessageField(value: chainParameter, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_ChainParameters, rhs: Protocol_ChainParameters) -> Bool {
        if lhs.chainParameter != rhs.chainParameter { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_ChainParameters.ChainParameter + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_ChainParameters.ChainParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_ChainParameters.protoMessageName + ".ChainParameter"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "key"),
        2: .same(proto: "value"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &key)
            case 2: try decoder.decodeSingularInt64Field(value: &value)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !key.isEmpty {
            try visitor.visitSingularStringField(value: key, fieldNumber: 1)
        }
        if value != 0 {
            try visitor.visitSingularInt64Field(value: value, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_ChainParameters.ChainParameter, rhs: Protocol_ChainParameters.ChainParameter) -> Bool {
        if lhs.key != rhs.key { return false }
        if lhs.value != rhs.value { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Account + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_Account: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Account"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "account_name"),
        2: .same(proto: "type"),
        3: .same(proto: "address"),
        4: .same(proto: "balance"),
        5: .same(proto: "votes"),
        6: .same(proto: "asset"),
        56: .same(proto: "assetV2"),
        7: .same(proto: "frozen"),
        8: .standard(proto: "net_usage"),
        41: .standard(proto: "acquired_delegated_frozen_balance_for_bandwidth"),
        42: .standard(proto: "delegated_frozen_balance_for_bandwidth"),
        46: .standard(proto: "old_tron_power"),
        47: .standard(proto: "tron_power"),
        60: .standard(proto: "asset_optimized"),
        9: .standard(proto: "create_time"),
        10: .standard(proto: "latest_opration_time"),
        11: .same(proto: "allowance"),
        12: .standard(proto: "latest_withdraw_time"),
        13: .same(proto: "code"),
        14: .standard(proto: "is_witness"),
        15: .standard(proto: "is_committee"),
        16: .standard(proto: "frozen_supply"),
        17: .standard(proto: "asset_issued_name"),
        57: .standard(proto: "asset_issued_ID"),
        18: .standard(proto: "latest_asset_operation_time"),
        58: .standard(proto: "latest_asset_operation_timeV2"),
        19: .standard(proto: "free_net_usage"),
        20: .standard(proto: "free_asset_net_usage"),
        59: .standard(proto: "free_asset_net_usageV2"),
        21: .standard(proto: "latest_consume_time"),
        22: .standard(proto: "latest_consume_free_time"),
        23: .standard(proto: "account_id"),
        24: .standard(proto: "net_window_size"),
        26: .standard(proto: "account_resource"),
        30: .same(proto: "codeHash"),
        31: .standard(proto: "owner_permission"),
        32: .standard(proto: "witness_permission"),
        33: .standard(proto: "active_permission"),
        34: .same(proto: "frozenV2"),
        35: .same(proto: "unfrozenV2"),
        36: .standard(proto: "delegated_frozenV2_balance_for_bandwidth"),
        37: .standard(proto: "acquired_delegated_frozenV2_balance_for_bandwidth"),
    ]

    fileprivate class _StorageClass {
        var _accountName: Data = .init()
        var _type: Protocol_AccountType = .normal
        var _address: Data = .init()
        var _balance: Int64 = 0
        var _votes: [Protocol_Vote] = []
        var _asset: [String: Int64] = [:]
        var _assetV2: [String: Int64] = [:]
        var _frozen: [Protocol_Account.Frozen] = []
        var _netUsage: Int64 = 0
        var _acquiredDelegatedFrozenBalanceForBandwidth: Int64 = 0
        var _delegatedFrozenBalanceForBandwidth: Int64 = 0
        var _oldTronPower: Int64 = 0
        var _tronPower: Protocol_Account.Frozen? = nil
        var _assetOptimized = false
        var _createTime: Int64 = 0
        var _latestOprationTime: Int64 = 0
        var _allowance: Int64 = 0
        var _latestWithdrawTime: Int64 = 0
        var _code: Data = .init()
        var _isWitness = false
        var _isCommittee = false
        var _frozenSupply: [Protocol_Account.Frozen] = []
        var _assetIssuedName: Data = .init()
        var _assetIssuedID: Data = .init()
        var _latestAssetOperationTime: [String: Int64] = [:]
        var _latestAssetOperationTimeV2: [String: Int64] = [:]
        var _freeNetUsage: Int64 = 0
        var _freeAssetNetUsage: [String: Int64] = [:]
        var _freeAssetNetUsageV2: [String: Int64] = [:]
        var _latestConsumeTime: Int64 = 0
        var _latestConsumeFreeTime: Int64 = 0
        var _accountID: Data = .init()
        var _netWindowSize: Int64 = 0
        var _accountResource: Protocol_Account.AccountResource? = nil
        var _codeHash: Data = .init()
        var _ownerPermission: Protocol_Permission? = nil
        var _witnessPermission: Protocol_Permission? = nil
        var _activePermission: [Protocol_Permission] = []
        var _frozenV2: [Protocol_Account.FreezeV2] = []
        var _unfrozenV2: [Protocol_Account.UnFreezeV2] = []
        var _delegatedFrozenV2BalanceForBandwidth: Int64 = 0
        var _acquiredDelegatedFrozenV2BalanceForBandwidth: Int64 = 0

        static let defaultInstance = _StorageClass()

        private init() { }

        init(copying source: _StorageClass) {
            _accountName = source._accountName
            _type = source._type
            _address = source._address
            _balance = source._balance
            _votes = source._votes
            _asset = source._asset
            _assetV2 = source._assetV2
            _frozen = source._frozen
            _netUsage = source._netUsage
            _acquiredDelegatedFrozenBalanceForBandwidth = source._acquiredDelegatedFrozenBalanceForBandwidth
            _delegatedFrozenBalanceForBandwidth = source._delegatedFrozenBalanceForBandwidth
            _oldTronPower = source._oldTronPower
            _tronPower = source._tronPower
            _assetOptimized = source._assetOptimized
            _createTime = source._createTime
            _latestOprationTime = source._latestOprationTime
            _allowance = source._allowance
            _latestWithdrawTime = source._latestWithdrawTime
            _code = source._code
            _isWitness = source._isWitness
            _isCommittee = source._isCommittee
            _frozenSupply = source._frozenSupply
            _assetIssuedName = source._assetIssuedName
            _assetIssuedID = source._assetIssuedID
            _latestAssetOperationTime = source._latestAssetOperationTime
            _latestAssetOperationTimeV2 = source._latestAssetOperationTimeV2
            _freeNetUsage = source._freeNetUsage
            _freeAssetNetUsage = source._freeAssetNetUsage
            _freeAssetNetUsageV2 = source._freeAssetNetUsageV2
            _latestConsumeTime = source._latestConsumeTime
            _latestConsumeFreeTime = source._latestConsumeFreeTime
            _accountID = source._accountID
            _netWindowSize = source._netWindowSize
            _accountResource = source._accountResource
            _codeHash = source._codeHash
            _ownerPermission = source._ownerPermission
            _witnessPermission = source._witnessPermission
            _activePermission = source._activePermission
            _frozenV2 = source._frozenV2
            _unfrozenV2 = source._unfrozenV2
            _delegatedFrozenV2BalanceForBandwidth = source._delegatedFrozenV2BalanceForBandwidth
            _acquiredDelegatedFrozenV2BalanceForBandwidth = source._acquiredDelegatedFrozenV2BalanceForBandwidth
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularBytesField(value: &_storage._accountName)

                case 2: try decoder.decodeSingularEnumField(value: &_storage._type)

                case 3: try decoder.decodeSingularBytesField(value: &_storage._address)

                case 4: try decoder.decodeSingularInt64Field(value: &_storage._balance)

                case 5: try decoder.decodeRepeatedMessageField(value: &_storage._votes)

                case 6: try decoder.decodeMapField(
                        fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufInt64>.self,
                        value: &_storage._asset
                    )

                case 7: try decoder.decodeRepeatedMessageField(value: &_storage._frozen)

                case 8: try decoder.decodeSingularInt64Field(value: &_storage._netUsage)

                case 9: try decoder.decodeSingularInt64Field(value: &_storage._createTime)

                case 10: try decoder.decodeSingularInt64Field(value: &_storage._latestOprationTime)

                case 11: try decoder.decodeSingularInt64Field(value: &_storage._allowance)

                case 12: try decoder.decodeSingularInt64Field(value: &_storage._latestWithdrawTime)

                case 13: try decoder.decodeSingularBytesField(value: &_storage._code)

                case 14: try decoder.decodeSingularBoolField(value: &_storage._isWitness)

                case 15: try decoder.decodeSingularBoolField(value: &_storage._isCommittee)

                case 16: try decoder.decodeRepeatedMessageField(value: &_storage._frozenSupply)

                case 17: try decoder.decodeSingularBytesField(value: &_storage._assetIssuedName)

                case 18: try decoder.decodeMapField(
                        fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufInt64>.self,
                        value: &_storage._latestAssetOperationTime
                    )

                case 19: try decoder.decodeSingularInt64Field(value: &_storage._freeNetUsage)

                case 20: try decoder.decodeMapField(
                        fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufInt64>.self,
                        value: &_storage._freeAssetNetUsage
                    )

                case 21: try decoder.decodeSingularInt64Field(value: &_storage._latestConsumeTime)

                case 22: try decoder.decodeSingularInt64Field(value: &_storage._latestConsumeFreeTime)

                case 23: try decoder.decodeSingularBytesField(value: &_storage._accountID)

                case 24: try decoder.decodeSingularInt64Field(value: &_storage._netWindowSize)

                case 26: try decoder.decodeSingularMessageField(value: &_storage._accountResource)

                case 30: try decoder.decodeSingularBytesField(value: &_storage._codeHash)

                case 31: try decoder.decodeSingularMessageField(value: &_storage._ownerPermission)

                case 32: try decoder.decodeSingularMessageField(value: &_storage._witnessPermission)

                case 33: try decoder.decodeRepeatedMessageField(value: &_storage._activePermission)

                case 34: try decoder.decodeRepeatedMessageField(value: &_storage._frozenV2)

                case 35: try decoder.decodeRepeatedMessageField(value: &_storage._unfrozenV2)

                case 36: try decoder.decodeSingularInt64Field(value: &_storage._delegatedFrozenV2BalanceForBandwidth)

                case 37: try decoder.decodeSingularInt64Field(value: &_storage._acquiredDelegatedFrozenV2BalanceForBandwidth)

                case 41: try decoder.decodeSingularInt64Field(value: &_storage._acquiredDelegatedFrozenBalanceForBandwidth)

                case 42: try decoder.decodeSingularInt64Field(value: &_storage._delegatedFrozenBalanceForBandwidth)

                case 46: try decoder.decodeSingularInt64Field(value: &_storage._oldTronPower)

                case 47: try decoder.decodeSingularMessageField(value: &_storage._tronPower)

                case 56: try decoder.decodeMapField(
                        fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufInt64>.self,
                        value: &_storage._assetV2
                    )

                case 57: try decoder.decodeSingularBytesField(value: &_storage._assetIssuedID)

                case 58: try decoder.decodeMapField(
                        fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufInt64>.self,
                        value: &_storage._latestAssetOperationTimeV2
                    )

                case 59: try decoder.decodeMapField(
                        fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufInt64>.self,
                        value: &_storage._freeAssetNetUsageV2
                    )

                case 60: try decoder.decodeSingularBoolField(value: &_storage._assetOptimized)

                default: break
                }
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            if !_storage._accountName.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._accountName, fieldNumber: 1)
            }
            if _storage._type != .normal {
                try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
            }
            if !_storage._address.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._address, fieldNumber: 3)
            }
            if _storage._balance != 0 {
                try visitor.visitSingularInt64Field(value: _storage._balance, fieldNumber: 4)
            }
            if !_storage._votes.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._votes, fieldNumber: 5)
            }
            if !_storage._asset.isEmpty {
                try visitor.visitMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufInt64>.self,
                    value: _storage._asset,
                    fieldNumber: 6
                )
            }
            if !_storage._frozen.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._frozen, fieldNumber: 7)
            }
            if _storage._netUsage != 0 {
                try visitor.visitSingularInt64Field(value: _storage._netUsage, fieldNumber: 8)
            }
            if _storage._createTime != 0 {
                try visitor.visitSingularInt64Field(value: _storage._createTime, fieldNumber: 9)
            }
            if _storage._latestOprationTime != 0 {
                try visitor.visitSingularInt64Field(value: _storage._latestOprationTime, fieldNumber: 10)
            }
            if _storage._allowance != 0 {
                try visitor.visitSingularInt64Field(value: _storage._allowance, fieldNumber: 11)
            }
            if _storage._latestWithdrawTime != 0 {
                try visitor.visitSingularInt64Field(value: _storage._latestWithdrawTime, fieldNumber: 12)
            }
            if !_storage._code.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._code, fieldNumber: 13)
            }
            if _storage._isWitness != false {
                try visitor.visitSingularBoolField(value: _storage._isWitness, fieldNumber: 14)
            }
            if _storage._isCommittee != false {
                try visitor.visitSingularBoolField(value: _storage._isCommittee, fieldNumber: 15)
            }
            if !_storage._frozenSupply.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._frozenSupply, fieldNumber: 16)
            }
            if !_storage._assetIssuedName.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._assetIssuedName, fieldNumber: 17)
            }
            if !_storage._latestAssetOperationTime.isEmpty {
                try visitor.visitMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufInt64>.self,
                    value: _storage._latestAssetOperationTime,
                    fieldNumber: 18
                )
            }
            if _storage._freeNetUsage != 0 {
                try visitor.visitSingularInt64Field(value: _storage._freeNetUsage, fieldNumber: 19)
            }
            if !_storage._freeAssetNetUsage.isEmpty {
                try visitor.visitMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufInt64>.self,
                    value: _storage._freeAssetNetUsage,
                    fieldNumber: 20
                )
            }
            if _storage._latestConsumeTime != 0 {
                try visitor.visitSingularInt64Field(value: _storage._latestConsumeTime, fieldNumber: 21)
            }
            if _storage._latestConsumeFreeTime != 0 {
                try visitor.visitSingularInt64Field(value: _storage._latestConsumeFreeTime, fieldNumber: 22)
            }
            if !_storage._accountID.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._accountID, fieldNumber: 23)
            }
            if _storage._netWindowSize != 0 {
                try visitor.visitSingularInt64Field(value: _storage._netWindowSize, fieldNumber: 24)
            }
            try { if let v = _storage._accountResource {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
            } }()
            if !_storage._codeHash.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._codeHash, fieldNumber: 30)
            }
            try { if let v = _storage._ownerPermission {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
            } }()
            try { if let v = _storage._witnessPermission {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
            } }()
            if !_storage._activePermission.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._activePermission, fieldNumber: 33)
            }
            if !_storage._frozenV2.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._frozenV2, fieldNumber: 34)
            }
            if !_storage._unfrozenV2.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._unfrozenV2, fieldNumber: 35)
            }
            if _storage._delegatedFrozenV2BalanceForBandwidth != 0 {
                try visitor.visitSingularInt64Field(value: _storage._delegatedFrozenV2BalanceForBandwidth, fieldNumber: 36)
            }
            if _storage._acquiredDelegatedFrozenV2BalanceForBandwidth != 0 {
                try visitor.visitSingularInt64Field(
                    value: _storage._acquiredDelegatedFrozenV2BalanceForBandwidth,
                    fieldNumber: 37
                )
            }
            if _storage._acquiredDelegatedFrozenBalanceForBandwidth != 0 {
                try visitor.visitSingularInt64Field(value: _storage._acquiredDelegatedFrozenBalanceForBandwidth, fieldNumber: 41)
            }
            if _storage._delegatedFrozenBalanceForBandwidth != 0 {
                try visitor.visitSingularInt64Field(value: _storage._delegatedFrozenBalanceForBandwidth, fieldNumber: 42)
            }
            if _storage._oldTronPower != 0 {
                try visitor.visitSingularInt64Field(value: _storage._oldTronPower, fieldNumber: 46)
            }
            try { if let v = _storage._tronPower {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
            } }()
            if !_storage._assetV2.isEmpty {
                try visitor.visitMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufInt64>.self,
                    value: _storage._assetV2,
                    fieldNumber: 56
                )
            }
            if !_storage._assetIssuedID.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._assetIssuedID, fieldNumber: 57)
            }
            if !_storage._latestAssetOperationTimeV2.isEmpty {
                try visitor.visitMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufInt64>.self,
                    value: _storage._latestAssetOperationTimeV2,
                    fieldNumber: 58
                )
            }
            if !_storage._freeAssetNetUsageV2.isEmpty {
                try visitor.visitMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufInt64>.self,
                    value: _storage._freeAssetNetUsageV2,
                    fieldNumber: 59
                )
            }
            if _storage._assetOptimized != false {
                try visitor.visitSingularBoolField(value: _storage._assetOptimized, fieldNumber: 60)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_Account, rhs: Protocol_Account) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((
                lhs._storage,
                rhs._storage
            )) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._accountName != rhs_storage._accountName { return false }
                if _storage._type != rhs_storage._type { return false }
                if _storage._address != rhs_storage._address { return false }
                if _storage._balance != rhs_storage._balance { return false }
                if _storage._votes != rhs_storage._votes { return false }
                if _storage._asset != rhs_storage._asset { return false }
                if _storage._assetV2 != rhs_storage._assetV2 { return false }
                if _storage._frozen != rhs_storage._frozen { return false }
                if _storage._netUsage != rhs_storage._netUsage { return false }
                if
                    _storage._acquiredDelegatedFrozenBalanceForBandwidth != rhs_storage
                        ._acquiredDelegatedFrozenBalanceForBandwidth { return false }
                if
                    _storage._delegatedFrozenBalanceForBandwidth != rhs_storage
                        ._delegatedFrozenBalanceForBandwidth { return false }
                if _storage._oldTronPower != rhs_storage._oldTronPower { return false }
                if _storage._tronPower != rhs_storage._tronPower { return false }
                if _storage._assetOptimized != rhs_storage._assetOptimized { return false }
                if _storage._createTime != rhs_storage._createTime { return false }
                if _storage._latestOprationTime != rhs_storage._latestOprationTime { return false }
                if _storage._allowance != rhs_storage._allowance { return false }
                if _storage._latestWithdrawTime != rhs_storage._latestWithdrawTime { return false }
                if _storage._code != rhs_storage._code { return false }
                if _storage._isWitness != rhs_storage._isWitness { return false }
                if _storage._isCommittee != rhs_storage._isCommittee { return false }
                if _storage._frozenSupply != rhs_storage._frozenSupply { return false }
                if _storage._assetIssuedName != rhs_storage._assetIssuedName { return false }
                if _storage._assetIssuedID != rhs_storage._assetIssuedID { return false }
                if _storage._latestAssetOperationTime != rhs_storage._latestAssetOperationTime { return false }
                if _storage._latestAssetOperationTimeV2 != rhs_storage._latestAssetOperationTimeV2 { return false }
                if _storage._freeNetUsage != rhs_storage._freeNetUsage { return false }
                if _storage._freeAssetNetUsage != rhs_storage._freeAssetNetUsage { return false }
                if _storage._freeAssetNetUsageV2 != rhs_storage._freeAssetNetUsageV2 { return false }
                if _storage._latestConsumeTime != rhs_storage._latestConsumeTime { return false }
                if _storage._latestConsumeFreeTime != rhs_storage._latestConsumeFreeTime { return false }
                if _storage._accountID != rhs_storage._accountID { return false }
                if _storage._netWindowSize != rhs_storage._netWindowSize { return false }
                if _storage._accountResource != rhs_storage._accountResource { return false }
                if _storage._codeHash != rhs_storage._codeHash { return false }
                if _storage._ownerPermission != rhs_storage._ownerPermission { return false }
                if _storage._witnessPermission != rhs_storage._witnessPermission { return false }
                if _storage._activePermission != rhs_storage._activePermission { return false }
                if _storage._frozenV2 != rhs_storage._frozenV2 { return false }
                if _storage._unfrozenV2 != rhs_storage._unfrozenV2 { return false }
                if
                    _storage._delegatedFrozenV2BalanceForBandwidth != rhs_storage
                        ._delegatedFrozenV2BalanceForBandwidth { return false }
                if
                    _storage._acquiredDelegatedFrozenV2BalanceForBandwidth != rhs_storage
                        ._acquiredDelegatedFrozenV2BalanceForBandwidth { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Account.Frozen + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_Account.Frozen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_Account.protoMessageName + ".Frozen"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "frozen_balance"),
        2: .standard(proto: "expire_time"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &frozenBalance)
            case 2: try decoder.decodeSingularInt64Field(value: &expireTime)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if frozenBalance != 0 {
            try visitor.visitSingularInt64Field(value: frozenBalance, fieldNumber: 1)
        }
        if expireTime != 0 {
            try visitor.visitSingularInt64Field(value: expireTime, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_Account.Frozen, rhs: Protocol_Account.Frozen) -> Bool {
        if lhs.frozenBalance != rhs.frozenBalance { return false }
        if lhs.expireTime != rhs.expireTime { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Account.AccountResource + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_Account.AccountResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_Account.protoMessageName + ".AccountResource"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "energy_usage"),
        2: .standard(proto: "frozen_balance_for_energy"),
        3: .standard(proto: "latest_consume_time_for_energy"),
        4: .standard(proto: "acquired_delegated_frozen_balance_for_energy"),
        5: .standard(proto: "delegated_frozen_balance_for_energy"),
        6: .standard(proto: "storage_limit"),
        7: .standard(proto: "storage_usage"),
        8: .standard(proto: "latest_exchange_storage_time"),
        9: .standard(proto: "energy_window_size"),
        10: .standard(proto: "delegated_frozenV2_balance_for_energy"),
        11: .standard(proto: "acquired_delegated_frozenV2_balance_for_energy"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &energyUsage)
            case 2: try decoder.decodeSingularMessageField(value: &_frozenBalanceForEnergy)
            case 3: try decoder.decodeSingularInt64Field(value: &latestConsumeTimeForEnergy)
            case 4: try decoder.decodeSingularInt64Field(value: &acquiredDelegatedFrozenBalanceForEnergy)
            case 5: try decoder.decodeSingularInt64Field(value: &delegatedFrozenBalanceForEnergy)
            case 6: try decoder.decodeSingularInt64Field(value: &storageLimit)
            case 7: try decoder.decodeSingularInt64Field(value: &storageUsage)
            case 8: try decoder.decodeSingularInt64Field(value: &latestExchangeStorageTime)
            case 9: try decoder.decodeSingularInt64Field(value: &energyWindowSize)
            case 10: try decoder.decodeSingularInt64Field(value: &delegatedFrozenV2BalanceForEnergy)
            case 11: try decoder.decodeSingularInt64Field(value: &acquiredDelegatedFrozenV2BalanceForEnergy)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if energyUsage != 0 {
            try visitor.visitSingularInt64Field(value: energyUsage, fieldNumber: 1)
        }
        try { if let v = self._frozenBalanceForEnergy {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if latestConsumeTimeForEnergy != 0 {
            try visitor.visitSingularInt64Field(value: latestConsumeTimeForEnergy, fieldNumber: 3)
        }
        if acquiredDelegatedFrozenBalanceForEnergy != 0 {
            try visitor.visitSingularInt64Field(value: acquiredDelegatedFrozenBalanceForEnergy, fieldNumber: 4)
        }
        if delegatedFrozenBalanceForEnergy != 0 {
            try visitor.visitSingularInt64Field(value: delegatedFrozenBalanceForEnergy, fieldNumber: 5)
        }
        if storageLimit != 0 {
            try visitor.visitSingularInt64Field(value: storageLimit, fieldNumber: 6)
        }
        if storageUsage != 0 {
            try visitor.visitSingularInt64Field(value: storageUsage, fieldNumber: 7)
        }
        if latestExchangeStorageTime != 0 {
            try visitor.visitSingularInt64Field(value: latestExchangeStorageTime, fieldNumber: 8)
        }
        if energyWindowSize != 0 {
            try visitor.visitSingularInt64Field(value: energyWindowSize, fieldNumber: 9)
        }
        if delegatedFrozenV2BalanceForEnergy != 0 {
            try visitor.visitSingularInt64Field(value: delegatedFrozenV2BalanceForEnergy, fieldNumber: 10)
        }
        if acquiredDelegatedFrozenV2BalanceForEnergy != 0 {
            try visitor.visitSingularInt64Field(value: acquiredDelegatedFrozenV2BalanceForEnergy, fieldNumber: 11)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_Account.AccountResource, rhs: Protocol_Account.AccountResource) -> Bool {
        if lhs.energyUsage != rhs.energyUsage { return false }
        if lhs._frozenBalanceForEnergy != rhs._frozenBalanceForEnergy { return false }
        if lhs.latestConsumeTimeForEnergy != rhs.latestConsumeTimeForEnergy { return false }
        if lhs.acquiredDelegatedFrozenBalanceForEnergy != rhs.acquiredDelegatedFrozenBalanceForEnergy { return false }
        if lhs.delegatedFrozenBalanceForEnergy != rhs.delegatedFrozenBalanceForEnergy { return false }
        if lhs.storageLimit != rhs.storageLimit { return false }
        if lhs.storageUsage != rhs.storageUsage { return false }
        if lhs.latestExchangeStorageTime != rhs.latestExchangeStorageTime { return false }
        if lhs.energyWindowSize != rhs.energyWindowSize { return false }
        if lhs.delegatedFrozenV2BalanceForEnergy != rhs.delegatedFrozenV2BalanceForEnergy { return false }
        if lhs.acquiredDelegatedFrozenV2BalanceForEnergy != rhs.acquiredDelegatedFrozenV2BalanceForEnergy { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Account.FreezeV2 + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_Account.FreezeV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_Account.protoMessageName + ".FreezeV2"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "amount"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &type)
            case 2: try decoder.decodeSingularInt64Field(value: &amount)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if type != .bandwidth {
            try visitor.visitSingularEnumField(value: type, fieldNumber: 1)
        }
        if amount != 0 {
            try visitor.visitSingularInt64Field(value: amount, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_Account.FreezeV2, rhs: Protocol_Account.FreezeV2) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.amount != rhs.amount { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Account.UnFreezeV2 + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_Account.UnFreezeV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_Account.protoMessageName + ".UnFreezeV2"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        3: .standard(proto: "unfreeze_amount"),
        4: .standard(proto: "unfreeze_expire_time"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &type)
            case 3: try decoder.decodeSingularInt64Field(value: &unfreezeAmount)
            case 4: try decoder.decodeSingularInt64Field(value: &unfreezeExpireTime)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if type != .bandwidth {
            try visitor.visitSingularEnumField(value: type, fieldNumber: 1)
        }
        if unfreezeAmount != 0 {
            try visitor.visitSingularInt64Field(value: unfreezeAmount, fieldNumber: 3)
        }
        if unfreezeExpireTime != 0 {
            try visitor.visitSingularInt64Field(value: unfreezeExpireTime, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_Account.UnFreezeV2, rhs: Protocol_Account.UnFreezeV2) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.unfreezeAmount != rhs.unfreezeAmount { return false }
        if lhs.unfreezeExpireTime != rhs.unfreezeExpireTime { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Key + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Key"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "address"),
        2: .same(proto: "weight"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &address)
            case 2: try decoder.decodeSingularInt64Field(value: &weight)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !address.isEmpty {
            try visitor.visitSingularBytesField(value: address, fieldNumber: 1)
        }
        if weight != 0 {
            try visitor.visitSingularInt64Field(value: weight, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_Key, rhs: Protocol_Key) -> Bool {
        if lhs.address != rhs.address { return false }
        if lhs.weight != rhs.weight { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_DelegatedResource + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_DelegatedResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".DelegatedResource"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "from"),
        2: .same(proto: "to"),
        3: .standard(proto: "frozen_balance_for_bandwidth"),
        4: .standard(proto: "frozen_balance_for_energy"),
        5: .standard(proto: "expire_time_for_bandwidth"),
        6: .standard(proto: "expire_time_for_energy"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &from)
            case 2: try decoder.decodeSingularBytesField(value: &to)
            case 3: try decoder.decodeSingularInt64Field(value: &frozenBalanceForBandwidth)
            case 4: try decoder.decodeSingularInt64Field(value: &frozenBalanceForEnergy)
            case 5: try decoder.decodeSingularInt64Field(value: &expireTimeForBandwidth)
            case 6: try decoder.decodeSingularInt64Field(value: &expireTimeForEnergy)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !from.isEmpty {
            try visitor.visitSingularBytesField(value: from, fieldNumber: 1)
        }
        if !to.isEmpty {
            try visitor.visitSingularBytesField(value: to, fieldNumber: 2)
        }
        if frozenBalanceForBandwidth != 0 {
            try visitor.visitSingularInt64Field(value: frozenBalanceForBandwidth, fieldNumber: 3)
        }
        if frozenBalanceForEnergy != 0 {
            try visitor.visitSingularInt64Field(value: frozenBalanceForEnergy, fieldNumber: 4)
        }
        if expireTimeForBandwidth != 0 {
            try visitor.visitSingularInt64Field(value: expireTimeForBandwidth, fieldNumber: 5)
        }
        if expireTimeForEnergy != 0 {
            try visitor.visitSingularInt64Field(value: expireTimeForEnergy, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_DelegatedResource, rhs: Protocol_DelegatedResource) -> Bool {
        if lhs.from != rhs.from { return false }
        if lhs.to != rhs.to { return false }
        if lhs.frozenBalanceForBandwidth != rhs.frozenBalanceForBandwidth { return false }
        if lhs.frozenBalanceForEnergy != rhs.frozenBalanceForEnergy { return false }
        if lhs.expireTimeForBandwidth != rhs.expireTimeForBandwidth { return false }
        if lhs.expireTimeForEnergy != rhs.expireTimeForEnergy { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_authority + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_authority: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".authority"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "account"),
        2: .standard(proto: "permission_name"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_account)
            case 2: try decoder.decodeSingularBytesField(value: &permissionName)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _account {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !permissionName.isEmpty {
            try visitor.visitSingularBytesField(value: permissionName, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_authority, rhs: Protocol_authority) -> Bool {
        if lhs._account != rhs._account { return false }
        if lhs.permissionName != rhs.permissionName { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Permission + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_Permission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".Permission"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "id"),
        3: .standard(proto: "permission_name"),
        4: .same(proto: "threshold"),
        5: .standard(proto: "parent_id"),
        6: .same(proto: "operations"),
        7: .same(proto: "keys"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &type)
            case 2: try decoder.decodeSingularInt32Field(value: &id)
            case 3: try decoder.decodeSingularStringField(value: &permissionName)
            case 4: try decoder.decodeSingularInt64Field(value: &threshold)
            case 5: try decoder.decodeSingularInt32Field(value: &parentID)
            case 6: try decoder.decodeSingularBytesField(value: &operations)
            case 7: try decoder.decodeRepeatedMessageField(value: &keys)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if type != .owner {
            try visitor.visitSingularEnumField(value: type, fieldNumber: 1)
        }
        if id != 0 {
            try visitor.visitSingularInt32Field(value: id, fieldNumber: 2)
        }
        if !permissionName.isEmpty {
            try visitor.visitSingularStringField(value: permissionName, fieldNumber: 3)
        }
        if threshold != 0 {
            try visitor.visitSingularInt64Field(value: threshold, fieldNumber: 4)
        }
        if parentID != 0 {
            try visitor.visitSingularInt32Field(value: parentID, fieldNumber: 5)
        }
        if !operations.isEmpty {
            try visitor.visitSingularBytesField(value: operations, fieldNumber: 6)
        }
        if !keys.isEmpty {
            try visitor.visitRepeatedMessageField(value: keys, fieldNumber: 7)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_Permission, rhs: Protocol_Permission) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.id != rhs.id { return false }
        if lhs.permissionName != rhs.permissionName { return false }
        if lhs.threshold != rhs.threshold { return false }
        if lhs.parentID != rhs.parentID { return false }
        if lhs.operations != rhs.operations { return false }
        if lhs.keys != rhs.keys { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Permission.PermissionType + SwiftProtobuf._ProtoNameProviding

extension Protocol_Permission.PermissionType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "Owner"),
        1: .same(proto: "Witness"),
        2: .same(proto: "Active"),
    ]
}

// MARK: - Protocol_Witness + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_Witness: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Witness"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "address"),
        2: .same(proto: "voteCount"),
        3: .same(proto: "pubKey"),
        4: .same(proto: "url"),
        5: .same(proto: "totalProduced"),
        6: .same(proto: "totalMissed"),
        7: .same(proto: "latestBlockNum"),
        8: .same(proto: "latestSlotNum"),
        9: .same(proto: "isJobs"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &address)
            case 2: try decoder.decodeSingularInt64Field(value: &voteCount)
            case 3: try decoder.decodeSingularBytesField(value: &pubKey)
            case 4: try decoder.decodeSingularStringField(value: &url)
            case 5: try decoder.decodeSingularInt64Field(value: &totalProduced)
            case 6: try decoder.decodeSingularInt64Field(value: &totalMissed)
            case 7: try decoder.decodeSingularInt64Field(value: &latestBlockNum)
            case 8: try decoder.decodeSingularInt64Field(value: &latestSlotNum)
            case 9: try decoder.decodeSingularBoolField(value: &isJobs)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !address.isEmpty {
            try visitor.visitSingularBytesField(value: address, fieldNumber: 1)
        }
        if voteCount != 0 {
            try visitor.visitSingularInt64Field(value: voteCount, fieldNumber: 2)
        }
        if !pubKey.isEmpty {
            try visitor.visitSingularBytesField(value: pubKey, fieldNumber: 3)
        }
        if !url.isEmpty {
            try visitor.visitSingularStringField(value: url, fieldNumber: 4)
        }
        if totalProduced != 0 {
            try visitor.visitSingularInt64Field(value: totalProduced, fieldNumber: 5)
        }
        if totalMissed != 0 {
            try visitor.visitSingularInt64Field(value: totalMissed, fieldNumber: 6)
        }
        if latestBlockNum != 0 {
            try visitor.visitSingularInt64Field(value: latestBlockNum, fieldNumber: 7)
        }
        if latestSlotNum != 0 {
            try visitor.visitSingularInt64Field(value: latestSlotNum, fieldNumber: 8)
        }
        if isJobs != false {
            try visitor.visitSingularBoolField(value: isJobs, fieldNumber: 9)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_Witness, rhs: Protocol_Witness) -> Bool {
        if lhs.address != rhs.address { return false }
        if lhs.voteCount != rhs.voteCount { return false }
        if lhs.pubKey != rhs.pubKey { return false }
        if lhs.url != rhs.url { return false }
        if lhs.totalProduced != rhs.totalProduced { return false }
        if lhs.totalMissed != rhs.totalMissed { return false }
        if lhs.latestBlockNum != rhs.latestBlockNum { return false }
        if lhs.latestSlotNum != rhs.latestSlotNum { return false }
        if lhs.isJobs != rhs.isJobs { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Votes + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_Votes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Votes"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "address"),
        2: .standard(proto: "old_votes"),
        3: .standard(proto: "new_votes"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &address)
            case 2: try decoder.decodeRepeatedMessageField(value: &oldVotes)
            case 3: try decoder.decodeRepeatedMessageField(value: &newVotes)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !address.isEmpty {
            try visitor.visitSingularBytesField(value: address, fieldNumber: 1)
        }
        if !oldVotes.isEmpty {
            try visitor.visitRepeatedMessageField(value: oldVotes, fieldNumber: 2)
        }
        if !newVotes.isEmpty {
            try visitor.visitRepeatedMessageField(value: newVotes, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_Votes, rhs: Protocol_Votes) -> Bool {
        if lhs.address != rhs.address { return false }
        if lhs.oldVotes != rhs.oldVotes { return false }
        if lhs.newVotes != rhs.newVotes { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_TXOutput + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_TXOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".TXOutput"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "value"),
        2: .same(proto: "pubKeyHash"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &value)
            case 2: try decoder.decodeSingularBytesField(value: &pubKeyHash)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if value != 0 {
            try visitor.visitSingularInt64Field(value: value, fieldNumber: 1)
        }
        if !pubKeyHash.isEmpty {
            try visitor.visitSingularBytesField(value: pubKeyHash, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_TXOutput, rhs: Protocol_TXOutput) -> Bool {
        if lhs.value != rhs.value { return false }
        if lhs.pubKeyHash != rhs.pubKeyHash { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_TXInput + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_TXInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".TXInput"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "raw_data"),
        4: .same(proto: "signature"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_rawData)
            case 4: try decoder.decodeSingularBytesField(value: &signature)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _rawData {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !signature.isEmpty {
            try visitor.visitSingularBytesField(value: signature, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_TXInput, rhs: Protocol_TXInput) -> Bool {
        if lhs._rawData != rhs._rawData { return false }
        if lhs.signature != rhs.signature { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_TXInput.raw + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_TXInput.raw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_TXInput.protoMessageName + ".raw"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "txID"),
        2: .same(proto: "vout"),
        3: .same(proto: "pubKey"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &txID)
            case 2: try decoder.decodeSingularInt64Field(value: &vout)
            case 3: try decoder.decodeSingularBytesField(value: &pubKey)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !txID.isEmpty {
            try visitor.visitSingularBytesField(value: txID, fieldNumber: 1)
        }
        if vout != 0 {
            try visitor.visitSingularInt64Field(value: vout, fieldNumber: 2)
        }
        if !pubKey.isEmpty {
            try visitor.visitSingularBytesField(value: pubKey, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_TXInput.raw, rhs: Protocol_TXInput.raw) -> Bool {
        if lhs.txID != rhs.txID { return false }
        if lhs.vout != rhs.vout { return false }
        if lhs.pubKey != rhs.pubKey { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_TXOutputs + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_TXOutputs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".TXOutputs"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "outputs"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &outputs)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !outputs.isEmpty {
            try visitor.visitRepeatedMessageField(value: outputs, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_TXOutputs, rhs: Protocol_TXOutputs) -> Bool {
        if lhs.outputs != rhs.outputs { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_ResourceReceipt + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_ResourceReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".ResourceReceipt"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "energy_usage"),
        2: .standard(proto: "energy_fee"),
        3: .standard(proto: "origin_energy_usage"),
        4: .standard(proto: "energy_usage_total"),
        5: .standard(proto: "net_usage"),
        6: .standard(proto: "net_fee"),
        7: .same(proto: "result"),
        8: .standard(proto: "energy_penalty_total"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &energyUsage)
            case 2: try decoder.decodeSingularInt64Field(value: &energyFee)
            case 3: try decoder.decodeSingularInt64Field(value: &originEnergyUsage)
            case 4: try decoder.decodeSingularInt64Field(value: &energyUsageTotal)
            case 5: try decoder.decodeSingularInt64Field(value: &netUsage)
            case 6: try decoder.decodeSingularInt64Field(value: &netFee)
            case 7: try decoder.decodeSingularEnumField(value: &result)
            case 8: try decoder.decodeSingularInt64Field(value: &energyPenaltyTotal)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if energyUsage != 0 {
            try visitor.visitSingularInt64Field(value: energyUsage, fieldNumber: 1)
        }
        if energyFee != 0 {
            try visitor.visitSingularInt64Field(value: energyFee, fieldNumber: 2)
        }
        if originEnergyUsage != 0 {
            try visitor.visitSingularInt64Field(value: originEnergyUsage, fieldNumber: 3)
        }
        if energyUsageTotal != 0 {
            try visitor.visitSingularInt64Field(value: energyUsageTotal, fieldNumber: 4)
        }
        if netUsage != 0 {
            try visitor.visitSingularInt64Field(value: netUsage, fieldNumber: 5)
        }
        if netFee != 0 {
            try visitor.visitSingularInt64Field(value: netFee, fieldNumber: 6)
        }
        if result != .default {
            try visitor.visitSingularEnumField(value: result, fieldNumber: 7)
        }
        if energyPenaltyTotal != 0 {
            try visitor.visitSingularInt64Field(value: energyPenaltyTotal, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_ResourceReceipt, rhs: Protocol_ResourceReceipt) -> Bool {
        if lhs.energyUsage != rhs.energyUsage { return false }
        if lhs.energyFee != rhs.energyFee { return false }
        if lhs.originEnergyUsage != rhs.originEnergyUsage { return false }
        if lhs.energyUsageTotal != rhs.energyUsageTotal { return false }
        if lhs.netUsage != rhs.netUsage { return false }
        if lhs.netFee != rhs.netFee { return false }
        if lhs.result != rhs.result { return false }
        if lhs.energyPenaltyTotal != rhs.energyPenaltyTotal { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MarketOrderDetail + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MarketOrderDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".MarketOrderDetail"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "makerOrderId"),
        2: .same(proto: "takerOrderId"),
        3: .same(proto: "fillSellQuantity"),
        4: .same(proto: "fillBuyQuantity"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &makerOrderID)
            case 2: try decoder.decodeSingularBytesField(value: &takerOrderID)
            case 3: try decoder.decodeSingularInt64Field(value: &fillSellQuantity)
            case 4: try decoder.decodeSingularInt64Field(value: &fillBuyQuantity)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !makerOrderID.isEmpty {
            try visitor.visitSingularBytesField(value: makerOrderID, fieldNumber: 1)
        }
        if !takerOrderID.isEmpty {
            try visitor.visitSingularBytesField(value: takerOrderID, fieldNumber: 2)
        }
        if fillSellQuantity != 0 {
            try visitor.visitSingularInt64Field(value: fillSellQuantity, fieldNumber: 3)
        }
        if fillBuyQuantity != 0 {
            try visitor.visitSingularInt64Field(value: fillBuyQuantity, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_MarketOrderDetail, rhs: Protocol_MarketOrderDetail) -> Bool {
        if lhs.makerOrderID != rhs.makerOrderID { return false }
        if lhs.takerOrderID != rhs.takerOrderID { return false }
        if lhs.fillSellQuantity != rhs.fillSellQuantity { return false }
        if lhs.fillBuyQuantity != rhs.fillBuyQuantity { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Transaction + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".Transaction"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "raw_data"),
        2: .same(proto: "signature"),
        5: .same(proto: "ret"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_rawData)
            case 2: try decoder.decodeRepeatedBytesField(value: &signature)
            case 5: try decoder.decodeRepeatedMessageField(value: &ret)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _rawData {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !signature.isEmpty {
            try visitor.visitRepeatedBytesField(value: signature, fieldNumber: 2)
        }
        if !ret.isEmpty {
            try visitor.visitRepeatedMessageField(value: ret, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_Transaction, rhs: Protocol_Transaction) -> Bool {
        if lhs._rawData != rhs._rawData { return false }
        if lhs.signature != rhs.signature { return false }
        if lhs.ret != rhs.ret { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Transaction.Contract + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_Transaction.Contract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_Transaction.protoMessageName + ".Contract"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "parameter"),
        3: .same(proto: "provider"),
        4: .same(proto: "ContractName"),
        5: .standard(proto: "Permission_id"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &type)
            case 2: try decoder.decodeSingularMessageField(value: &_parameter)
            case 3: try decoder.decodeSingularBytesField(value: &provider)
            case 4: try decoder.decodeSingularBytesField(value: &contractName)
            case 5: try decoder.decodeSingularInt32Field(value: &permissionID)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if type != .accountCreateContract {
            try visitor.visitSingularEnumField(value: type, fieldNumber: 1)
        }
        try { if let v = self._parameter {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if !provider.isEmpty {
            try visitor.visitSingularBytesField(value: provider, fieldNumber: 3)
        }
        if !contractName.isEmpty {
            try visitor.visitSingularBytesField(value: contractName, fieldNumber: 4)
        }
        if permissionID != 0 {
            try visitor.visitSingularInt32Field(value: permissionID, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_Transaction.Contract, rhs: Protocol_Transaction.Contract) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs._parameter != rhs._parameter { return false }
        if lhs.provider != rhs.provider { return false }
        if lhs.contractName != rhs.contractName { return false }
        if lhs.permissionID != rhs.permissionID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Transaction.Contract.ContractType + SwiftProtobuf._ProtoNameProviding

extension Protocol_Transaction.Contract.ContractType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "AccountCreateContract"),
        1: .same(proto: "TransferContract"),
        2: .same(proto: "TransferAssetContract"),
        3: .same(proto: "VoteAssetContract"),
        4: .same(proto: "VoteWitnessContract"),
        5: .same(proto: "WitnessCreateContract"),
        6: .same(proto: "AssetIssueContract"),
        8: .same(proto: "WitnessUpdateContract"),
        9: .same(proto: "ParticipateAssetIssueContract"),
        10: .same(proto: "AccountUpdateContract"),
        11: .same(proto: "FreezeBalanceContract"),
        12: .same(proto: "UnfreezeBalanceContract"),
        13: .same(proto: "WithdrawBalanceContract"),
        14: .same(proto: "UnfreezeAssetContract"),
        15: .same(proto: "UpdateAssetContract"),
        16: .same(proto: "ProposalCreateContract"),
        17: .same(proto: "ProposalApproveContract"),
        18: .same(proto: "ProposalDeleteContract"),
        19: .same(proto: "SetAccountIdContract"),
        20: .same(proto: "CustomContract"),
        30: .same(proto: "CreateSmartContract"),
        31: .same(proto: "TriggerSmartContract"),
        32: .same(proto: "GetContract"),
        33: .same(proto: "UpdateSettingContract"),
        41: .same(proto: "ExchangeCreateContract"),
        42: .same(proto: "ExchangeInjectContract"),
        43: .same(proto: "ExchangeWithdrawContract"),
        44: .same(proto: "ExchangeTransactionContract"),
        45: .same(proto: "UpdateEnergyLimitContract"),
        46: .same(proto: "AccountPermissionUpdateContract"),
        48: .same(proto: "ClearABIContract"),
        49: .same(proto: "UpdateBrokerageContract"),
        51: .same(proto: "ShieldedTransferContract"),
        52: .same(proto: "MarketSellAssetContract"),
        53: .same(proto: "MarketCancelOrderContract"),
        54: .same(proto: "FreezeBalanceV2Contract"),
        55: .same(proto: "UnfreezeBalanceV2Contract"),
        56: .same(proto: "WithdrawExpireUnfreezeContract"),
        57: .same(proto: "DelegateResourceContract"),
        58: .same(proto: "UnDelegateResourceContract"),
    ]
}

// MARK: - Protocol_Transaction.Result + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_Transaction.Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_Transaction.protoMessageName + ".Result"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "fee"),
        2: .same(proto: "ret"),
        3: .same(proto: "contractRet"),
        14: .same(proto: "assetIssueID"),
        15: .standard(proto: "withdraw_amount"),
        16: .standard(proto: "unfreeze_amount"),
        18: .standard(proto: "exchange_received_amount"),
        19: .standard(proto: "exchange_inject_another_amount"),
        20: .standard(proto: "exchange_withdraw_another_amount"),
        21: .standard(proto: "exchange_id"),
        22: .standard(proto: "shielded_transaction_fee"),
        25: .same(proto: "orderId"),
        26: .same(proto: "orderDetails"),
        27: .standard(proto: "withdraw_expire_amount"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &fee)
            case 2: try decoder.decodeSingularEnumField(value: &ret)
            case 3: try decoder.decodeSingularEnumField(value: &contractRet)
            case 14: try decoder.decodeSingularStringField(value: &assetIssueID)
            case 15: try decoder.decodeSingularInt64Field(value: &withdrawAmount)
            case 16: try decoder.decodeSingularInt64Field(value: &unfreezeAmount)
            case 18: try decoder.decodeSingularInt64Field(value: &exchangeReceivedAmount)
            case 19: try decoder.decodeSingularInt64Field(value: &exchangeInjectAnotherAmount)
            case 20: try decoder.decodeSingularInt64Field(value: &exchangeWithdrawAnotherAmount)
            case 21: try decoder.decodeSingularInt64Field(value: &exchangeID)
            case 22: try decoder.decodeSingularInt64Field(value: &shieldedTransactionFee)
            case 25: try decoder.decodeSingularBytesField(value: &orderID)
            case 26: try decoder.decodeRepeatedMessageField(value: &orderDetails)
            case 27: try decoder.decodeSingularInt64Field(value: &withdrawExpireAmount)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if fee != 0 {
            try visitor.visitSingularInt64Field(value: fee, fieldNumber: 1)
        }
        if ret != .sucess {
            try visitor.visitSingularEnumField(value: ret, fieldNumber: 2)
        }
        if contractRet != .default {
            try visitor.visitSingularEnumField(value: contractRet, fieldNumber: 3)
        }
        if !assetIssueID.isEmpty {
            try visitor.visitSingularStringField(value: assetIssueID, fieldNumber: 14)
        }
        if withdrawAmount != 0 {
            try visitor.visitSingularInt64Field(value: withdrawAmount, fieldNumber: 15)
        }
        if unfreezeAmount != 0 {
            try visitor.visitSingularInt64Field(value: unfreezeAmount, fieldNumber: 16)
        }
        if exchangeReceivedAmount != 0 {
            try visitor.visitSingularInt64Field(value: exchangeReceivedAmount, fieldNumber: 18)
        }
        if exchangeInjectAnotherAmount != 0 {
            try visitor.visitSingularInt64Field(value: exchangeInjectAnotherAmount, fieldNumber: 19)
        }
        if exchangeWithdrawAnotherAmount != 0 {
            try visitor.visitSingularInt64Field(value: exchangeWithdrawAnotherAmount, fieldNumber: 20)
        }
        if exchangeID != 0 {
            try visitor.visitSingularInt64Field(value: exchangeID, fieldNumber: 21)
        }
        if shieldedTransactionFee != 0 {
            try visitor.visitSingularInt64Field(value: shieldedTransactionFee, fieldNumber: 22)
        }
        if !orderID.isEmpty {
            try visitor.visitSingularBytesField(value: orderID, fieldNumber: 25)
        }
        if !orderDetails.isEmpty {
            try visitor.visitRepeatedMessageField(value: orderDetails, fieldNumber: 26)
        }
        if withdrawExpireAmount != 0 {
            try visitor.visitSingularInt64Field(value: withdrawExpireAmount, fieldNumber: 27)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_Transaction.Result, rhs: Protocol_Transaction.Result) -> Bool {
        if lhs.fee != rhs.fee { return false }
        if lhs.ret != rhs.ret { return false }
        if lhs.contractRet != rhs.contractRet { return false }
        if lhs.assetIssueID != rhs.assetIssueID { return false }
        if lhs.withdrawAmount != rhs.withdrawAmount { return false }
        if lhs.unfreezeAmount != rhs.unfreezeAmount { return false }
        if lhs.exchangeReceivedAmount != rhs.exchangeReceivedAmount { return false }
        if lhs.exchangeInjectAnotherAmount != rhs.exchangeInjectAnotherAmount { return false }
        if lhs.exchangeWithdrawAnotherAmount != rhs.exchangeWithdrawAnotherAmount { return false }
        if lhs.exchangeID != rhs.exchangeID { return false }
        if lhs.shieldedTransactionFee != rhs.shieldedTransactionFee { return false }
        if lhs.orderID != rhs.orderID { return false }
        if lhs.orderDetails != rhs.orderDetails { return false }
        if lhs.withdrawExpireAmount != rhs.withdrawExpireAmount { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Transaction.Result.code + SwiftProtobuf._ProtoNameProviding

extension Protocol_Transaction.Result.code: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "SUCESS"),
        1: .same(proto: "FAILED"),
    ]
}

// MARK: - Protocol_Transaction.Result.contractResult + SwiftProtobuf._ProtoNameProviding

extension Protocol_Transaction.Result.contractResult: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "DEFAULT"),
        1: .same(proto: "SUCCESS"),
        2: .same(proto: "REVERT"),
        3: .same(proto: "BAD_JUMP_DESTINATION"),
        4: .same(proto: "OUT_OF_MEMORY"),
        5: .same(proto: "PRECOMPILED_CONTRACT"),
        6: .same(proto: "STACK_TOO_SMALL"),
        7: .same(proto: "STACK_TOO_LARGE"),
        8: .same(proto: "ILLEGAL_OPERATION"),
        9: .same(proto: "STACK_OVERFLOW"),
        10: .same(proto: "OUT_OF_ENERGY"),
        11: .same(proto: "OUT_OF_TIME"),
        12: .same(proto: "JVM_STACK_OVER_FLOW"),
        13: .same(proto: "UNKNOWN"),
        14: .same(proto: "TRANSFER_FAILED"),
        15: .same(proto: "INVALID_CODE"),
    ]
}

// MARK: - Protocol_Transaction.raw + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_Transaction.raw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_Transaction.protoMessageName + ".raw"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "ref_block_bytes"),
        3: .standard(proto: "ref_block_num"),
        4: .standard(proto: "ref_block_hash"),
        8: .same(proto: "expiration"),
        9: .same(proto: "auths"),
        10: .same(proto: "data"),
        11: .same(proto: "contract"),
        12: .same(proto: "scripts"),
        14: .same(proto: "timestamp"),
        18: .standard(proto: "fee_limit"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &refBlockBytes)
            case 3: try decoder.decodeSingularInt64Field(value: &refBlockNum)
            case 4: try decoder.decodeSingularBytesField(value: &refBlockHash)
            case 8: try decoder.decodeSingularInt64Field(value: &expiration)
            case 9: try decoder.decodeRepeatedMessageField(value: &auths)
            case 10: try decoder.decodeSingularBytesField(value: &data)
            case 11: try decoder.decodeRepeatedMessageField(value: &contract)
            case 12: try decoder.decodeSingularBytesField(value: &scripts)
            case 14: try decoder.decodeSingularInt64Field(value: &timestamp)
            case 18: try decoder.decodeSingularInt64Field(value: &feeLimit)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !refBlockBytes.isEmpty {
            try visitor.visitSingularBytesField(value: refBlockBytes, fieldNumber: 1)
        }
        if refBlockNum != 0 {
            try visitor.visitSingularInt64Field(value: refBlockNum, fieldNumber: 3)
        }
        if !refBlockHash.isEmpty {
            try visitor.visitSingularBytesField(value: refBlockHash, fieldNumber: 4)
        }
        if expiration != 0 {
            try visitor.visitSingularInt64Field(value: expiration, fieldNumber: 8)
        }
        if !auths.isEmpty {
            try visitor.visitRepeatedMessageField(value: auths, fieldNumber: 9)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 10)
        }
        if !contract.isEmpty {
            try visitor.visitRepeatedMessageField(value: contract, fieldNumber: 11)
        }
        if !scripts.isEmpty {
            try visitor.visitSingularBytesField(value: scripts, fieldNumber: 12)
        }
        if timestamp != 0 {
            try visitor.visitSingularInt64Field(value: timestamp, fieldNumber: 14)
        }
        if feeLimit != 0 {
            try visitor.visitSingularInt64Field(value: feeLimit, fieldNumber: 18)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_Transaction.raw, rhs: Protocol_Transaction.raw) -> Bool {
        if lhs.refBlockBytes != rhs.refBlockBytes { return false }
        if lhs.refBlockNum != rhs.refBlockNum { return false }
        if lhs.refBlockHash != rhs.refBlockHash { return false }
        if lhs.expiration != rhs.expiration { return false }
        if lhs.auths != rhs.auths { return false }
        if lhs.data != rhs.data { return false }
        if lhs.contract != rhs.contract { return false }
        if lhs.scripts != rhs.scripts { return false }
        if lhs.timestamp != rhs.timestamp { return false }
        if lhs.feeLimit != rhs.feeLimit { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_TransactionInfo + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_TransactionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".TransactionInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "fee"),
        3: .same(proto: "blockNumber"),
        4: .same(proto: "blockTimeStamp"),
        5: .same(proto: "contractResult"),
        6: .standard(proto: "contract_address"),
        7: .same(proto: "receipt"),
        8: .same(proto: "log"),
        9: .same(proto: "result"),
        10: .same(proto: "resMessage"),
        14: .same(proto: "assetIssueID"),
        15: .standard(proto: "withdraw_amount"),
        16: .standard(proto: "unfreeze_amount"),
        17: .standard(proto: "internal_transactions"),
        18: .standard(proto: "exchange_received_amount"),
        19: .standard(proto: "exchange_inject_another_amount"),
        20: .standard(proto: "exchange_withdraw_another_amount"),
        21: .standard(proto: "exchange_id"),
        22: .standard(proto: "shielded_transaction_fee"),
        25: .same(proto: "orderId"),
        26: .same(proto: "orderDetails"),
        27: .same(proto: "packingFee"),
        28: .standard(proto: "withdraw_expire_amount"),
    ]

    fileprivate class _StorageClass {
        var _id: Data = .init()
        var _fee: Int64 = 0
        var _blockNumber: Int64 = 0
        var _blockTimeStamp: Int64 = 0
        var _contractResult: [Data] = []
        var _contractAddress: Data = .init()
        var _receipt: Protocol_ResourceReceipt? = nil
        var _log: [Protocol_TransactionInfo.Log] = []
        var _result: Protocol_TransactionInfo.code = .sucess
        var _resMessage: Data = .init()
        var _assetIssueID: String = .init()
        var _withdrawAmount: Int64 = 0
        var _unfreezeAmount: Int64 = 0
        var _internalTransactions: [Protocol_InternalTransaction] = []
        var _exchangeReceivedAmount: Int64 = 0
        var _exchangeInjectAnotherAmount: Int64 = 0
        var _exchangeWithdrawAnotherAmount: Int64 = 0
        var _exchangeID: Int64 = 0
        var _shieldedTransactionFee: Int64 = 0
        var _orderID: Data = .init()
        var _orderDetails: [Protocol_MarketOrderDetail] = []
        var _packingFee: Int64 = 0
        var _withdrawExpireAmount: Int64 = 0

        static let defaultInstance = _StorageClass()

        private init() { }

        init(copying source: _StorageClass) {
            _id = source._id
            _fee = source._fee
            _blockNumber = source._blockNumber
            _blockTimeStamp = source._blockTimeStamp
            _contractResult = source._contractResult
            _contractAddress = source._contractAddress
            _receipt = source._receipt
            _log = source._log
            _result = source._result
            _resMessage = source._resMessage
            _assetIssueID = source._assetIssueID
            _withdrawAmount = source._withdrawAmount
            _unfreezeAmount = source._unfreezeAmount
            _internalTransactions = source._internalTransactions
            _exchangeReceivedAmount = source._exchangeReceivedAmount
            _exchangeInjectAnotherAmount = source._exchangeInjectAnotherAmount
            _exchangeWithdrawAnotherAmount = source._exchangeWithdrawAnotherAmount
            _exchangeID = source._exchangeID
            _shieldedTransactionFee = source._shieldedTransactionFee
            _orderID = source._orderID
            _orderDetails = source._orderDetails
            _packingFee = source._packingFee
            _withdrawExpireAmount = source._withdrawExpireAmount
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularBytesField(value: &_storage._id)
                case 2: try decoder.decodeSingularInt64Field(value: &_storage._fee)
                case 3: try decoder.decodeSingularInt64Field(value: &_storage._blockNumber)
                case 4: try decoder.decodeSingularInt64Field(value: &_storage._blockTimeStamp)
                case 5: try decoder.decodeRepeatedBytesField(value: &_storage._contractResult)
                case 6: try decoder.decodeSingularBytesField(value: &_storage._contractAddress)
                case 7: try decoder.decodeSingularMessageField(value: &_storage._receipt)
                case 8: try decoder.decodeRepeatedMessageField(value: &_storage._log)
                case 9: try decoder.decodeSingularEnumField(value: &_storage._result)
                case 10: try decoder.decodeSingularBytesField(value: &_storage._resMessage)
                case 14: try decoder.decodeSingularStringField(value: &_storage._assetIssueID)
                case 15: try decoder.decodeSingularInt64Field(value: &_storage._withdrawAmount)
                case 16: try decoder.decodeSingularInt64Field(value: &_storage._unfreezeAmount)
                case 17: try decoder.decodeRepeatedMessageField(value: &_storage._internalTransactions)
                case 18: try decoder.decodeSingularInt64Field(value: &_storage._exchangeReceivedAmount)
                case 19: try decoder.decodeSingularInt64Field(value: &_storage._exchangeInjectAnotherAmount)
                case 20: try decoder.decodeSingularInt64Field(value: &_storage._exchangeWithdrawAnotherAmount)
                case 21: try decoder.decodeSingularInt64Field(value: &_storage._exchangeID)
                case 22: try decoder.decodeSingularInt64Field(value: &_storage._shieldedTransactionFee)
                case 25: try decoder.decodeSingularBytesField(value: &_storage._orderID)
                case 26: try decoder.decodeRepeatedMessageField(value: &_storage._orderDetails)
                case 27: try decoder.decodeSingularInt64Field(value: &_storage._packingFee)
                case 28: try decoder.decodeSingularInt64Field(value: &_storage._withdrawExpireAmount)
                default: break
                }
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            if !_storage._id.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._id, fieldNumber: 1)
            }
            if _storage._fee != 0 {
                try visitor.visitSingularInt64Field(value: _storage._fee, fieldNumber: 2)
            }
            if _storage._blockNumber != 0 {
                try visitor.visitSingularInt64Field(value: _storage._blockNumber, fieldNumber: 3)
            }
            if _storage._blockTimeStamp != 0 {
                try visitor.visitSingularInt64Field(value: _storage._blockTimeStamp, fieldNumber: 4)
            }
            if !_storage._contractResult.isEmpty {
                try visitor.visitRepeatedBytesField(value: _storage._contractResult, fieldNumber: 5)
            }
            if !_storage._contractAddress.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._contractAddress, fieldNumber: 6)
            }
            try { if let v = _storage._receipt {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            } }()
            if !_storage._log.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._log, fieldNumber: 8)
            }
            if _storage._result != .sucess {
                try visitor.visitSingularEnumField(value: _storage._result, fieldNumber: 9)
            }
            if !_storage._resMessage.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._resMessage, fieldNumber: 10)
            }
            if !_storage._assetIssueID.isEmpty {
                try visitor.visitSingularStringField(value: _storage._assetIssueID, fieldNumber: 14)
            }
            if _storage._withdrawAmount != 0 {
                try visitor.visitSingularInt64Field(value: _storage._withdrawAmount, fieldNumber: 15)
            }
            if _storage._unfreezeAmount != 0 {
                try visitor.visitSingularInt64Field(value: _storage._unfreezeAmount, fieldNumber: 16)
            }
            if !_storage._internalTransactions.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._internalTransactions, fieldNumber: 17)
            }
            if _storage._exchangeReceivedAmount != 0 {
                try visitor.visitSingularInt64Field(value: _storage._exchangeReceivedAmount, fieldNumber: 18)
            }
            if _storage._exchangeInjectAnotherAmount != 0 {
                try visitor.visitSingularInt64Field(value: _storage._exchangeInjectAnotherAmount, fieldNumber: 19)
            }
            if _storage._exchangeWithdrawAnotherAmount != 0 {
                try visitor.visitSingularInt64Field(value: _storage._exchangeWithdrawAnotherAmount, fieldNumber: 20)
            }
            if _storage._exchangeID != 0 {
                try visitor.visitSingularInt64Field(value: _storage._exchangeID, fieldNumber: 21)
            }
            if _storage._shieldedTransactionFee != 0 {
                try visitor.visitSingularInt64Field(value: _storage._shieldedTransactionFee, fieldNumber: 22)
            }
            if !_storage._orderID.isEmpty {
                try visitor.visitSingularBytesField(value: _storage._orderID, fieldNumber: 25)
            }
            if !_storage._orderDetails.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._orderDetails, fieldNumber: 26)
            }
            if _storage._packingFee != 0 {
                try visitor.visitSingularInt64Field(value: _storage._packingFee, fieldNumber: 27)
            }
            if _storage._withdrawExpireAmount != 0 {
                try visitor.visitSingularInt64Field(value: _storage._withdrawExpireAmount, fieldNumber: 28)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_TransactionInfo, rhs: Protocol_TransactionInfo) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((
                lhs._storage,
                rhs._storage
            )) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._id != rhs_storage._id { return false }
                if _storage._fee != rhs_storage._fee { return false }
                if _storage._blockNumber != rhs_storage._blockNumber { return false }
                if _storage._blockTimeStamp != rhs_storage._blockTimeStamp { return false }
                if _storage._contractResult != rhs_storage._contractResult { return false }
                if _storage._contractAddress != rhs_storage._contractAddress { return false }
                if _storage._receipt != rhs_storage._receipt { return false }
                if _storage._log != rhs_storage._log { return false }
                if _storage._result != rhs_storage._result { return false }
                if _storage._resMessage != rhs_storage._resMessage { return false }
                if _storage._assetIssueID != rhs_storage._assetIssueID { return false }
                if _storage._withdrawAmount != rhs_storage._withdrawAmount { return false }
                if _storage._unfreezeAmount != rhs_storage._unfreezeAmount { return false }
                if _storage._internalTransactions != rhs_storage._internalTransactions { return false }
                if _storage._exchangeReceivedAmount != rhs_storage._exchangeReceivedAmount { return false }
                if _storage._exchangeInjectAnotherAmount != rhs_storage._exchangeInjectAnotherAmount { return false }
                if _storage._exchangeWithdrawAnotherAmount != rhs_storage._exchangeWithdrawAnotherAmount { return false }
                if _storage._exchangeID != rhs_storage._exchangeID { return false }
                if _storage._shieldedTransactionFee != rhs_storage._shieldedTransactionFee { return false }
                if _storage._orderID != rhs_storage._orderID { return false }
                if _storage._orderDetails != rhs_storage._orderDetails { return false }
                if _storage._packingFee != rhs_storage._packingFee { return false }
                if _storage._withdrawExpireAmount != rhs_storage._withdrawExpireAmount { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_TransactionInfo.code + SwiftProtobuf._ProtoNameProviding

extension Protocol_TransactionInfo.code: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "SUCESS"),
        1: .same(proto: "FAILED"),
    ]
}

// MARK: - Protocol_TransactionInfo.Log + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_TransactionInfo.Log: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_TransactionInfo.protoMessageName + ".Log"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "address"),
        2: .same(proto: "topics"),
        3: .same(proto: "data"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &address)
            case 2: try decoder.decodeRepeatedBytesField(value: &topics)
            case 3: try decoder.decodeSingularBytesField(value: &data)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !address.isEmpty {
            try visitor.visitSingularBytesField(value: address, fieldNumber: 1)
        }
        if !topics.isEmpty {
            try visitor.visitRepeatedBytesField(value: topics, fieldNumber: 2)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_TransactionInfo.Log, rhs: Protocol_TransactionInfo.Log) -> Bool {
        if lhs.address != rhs.address { return false }
        if lhs.topics != rhs.topics { return false }
        if lhs.data != rhs.data { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_TransactionRet + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_TransactionRet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".TransactionRet"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "blockNumber"),
        2: .same(proto: "blockTimeStamp"),
        3: .same(proto: "transactioninfo"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &blockNumber)
            case 2: try decoder.decodeSingularInt64Field(value: &blockTimeStamp)
            case 3: try decoder.decodeRepeatedMessageField(value: &transactioninfo)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if blockNumber != 0 {
            try visitor.visitSingularInt64Field(value: blockNumber, fieldNumber: 1)
        }
        if blockTimeStamp != 0 {
            try visitor.visitSingularInt64Field(value: blockTimeStamp, fieldNumber: 2)
        }
        if !transactioninfo.isEmpty {
            try visitor.visitRepeatedMessageField(value: transactioninfo, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_TransactionRet, rhs: Protocol_TransactionRet) -> Bool {
        if lhs.blockNumber != rhs.blockNumber { return false }
        if lhs.blockTimeStamp != rhs.blockTimeStamp { return false }
        if lhs.transactioninfo != rhs.transactioninfo { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Transactions + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_Transactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".Transactions"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "transactions"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &transactions)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !transactions.isEmpty {
            try visitor.visitRepeatedMessageField(value: transactions, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_Transactions, rhs: Protocol_Transactions) -> Bool {
        if lhs.transactions != rhs.transactions { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_BlockHeader + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_BlockHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".BlockHeader"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "raw_data"),
        2: .standard(proto: "witness_signature"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_rawData)
            case 2: try decoder.decodeSingularBytesField(value: &witnessSignature)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _rawData {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !witnessSignature.isEmpty {
            try visitor.visitSingularBytesField(value: witnessSignature, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_BlockHeader, rhs: Protocol_BlockHeader) -> Bool {
        if lhs._rawData != rhs._rawData { return false }
        if lhs.witnessSignature != rhs.witnessSignature { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_BlockHeader.raw + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_BlockHeader.raw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_BlockHeader.protoMessageName + ".raw"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "timestamp"),
        2: .same(proto: "txTrieRoot"),
        3: .same(proto: "parentHash"),
        7: .same(proto: "number"),
        8: .standard(proto: "witness_id"),
        9: .standard(proto: "witness_address"),
        10: .same(proto: "version"),
        11: .same(proto: "accountStateRoot"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &timestamp)
            case 2: try decoder.decodeSingularBytesField(value: &txTrieRoot)
            case 3: try decoder.decodeSingularBytesField(value: &parentHash)
            case 7: try decoder.decodeSingularInt64Field(value: &number)
            case 8: try decoder.decodeSingularInt64Field(value: &witnessID)
            case 9: try decoder.decodeSingularBytesField(value: &witnessAddress)
            case 10: try decoder.decodeSingularInt32Field(value: &version)
            case 11: try decoder.decodeSingularBytesField(value: &accountStateRoot)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if timestamp != 0 {
            try visitor.visitSingularInt64Field(value: timestamp, fieldNumber: 1)
        }
        if !txTrieRoot.isEmpty {
            try visitor.visitSingularBytesField(value: txTrieRoot, fieldNumber: 2)
        }
        if !parentHash.isEmpty {
            try visitor.visitSingularBytesField(value: parentHash, fieldNumber: 3)
        }
        if number != 0 {
            try visitor.visitSingularInt64Field(value: number, fieldNumber: 7)
        }
        if witnessID != 0 {
            try visitor.visitSingularInt64Field(value: witnessID, fieldNumber: 8)
        }
        if !witnessAddress.isEmpty {
            try visitor.visitSingularBytesField(value: witnessAddress, fieldNumber: 9)
        }
        if version != 0 {
            try visitor.visitSingularInt32Field(value: version, fieldNumber: 10)
        }
        if !accountStateRoot.isEmpty {
            try visitor.visitSingularBytesField(value: accountStateRoot, fieldNumber: 11)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_BlockHeader.raw, rhs: Protocol_BlockHeader.raw) -> Bool {
        if lhs.timestamp != rhs.timestamp { return false }
        if lhs.txTrieRoot != rhs.txTrieRoot { return false }
        if lhs.parentHash != rhs.parentHash { return false }
        if lhs.number != rhs.number { return false }
        if lhs.witnessID != rhs.witnessID { return false }
        if lhs.witnessAddress != rhs.witnessAddress { return false }
        if lhs.version != rhs.version { return false }
        if lhs.accountStateRoot != rhs.accountStateRoot { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Block + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_Block: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Block"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "transactions"),
        2: .standard(proto: "block_header"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &transactions)
            case 2: try decoder.decodeSingularMessageField(value: &_blockHeader)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !transactions.isEmpty {
            try visitor.visitRepeatedMessageField(value: transactions, fieldNumber: 1)
        }
        try { if let v = self._blockHeader {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_Block, rhs: Protocol_Block) -> Bool {
        if lhs.transactions != rhs.transactions { return false }
        if lhs._blockHeader != rhs._blockHeader { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_ChainInventory + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_ChainInventory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".ChainInventory"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ids"),
        2: .standard(proto: "remain_num"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &ids)
            case 2: try decoder.decodeSingularInt64Field(value: &remainNum)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !ids.isEmpty {
            try visitor.visitRepeatedMessageField(value: ids, fieldNumber: 1)
        }
        if remainNum != 0 {
            try visitor.visitSingularInt64Field(value: remainNum, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_ChainInventory, rhs: Protocol_ChainInventory) -> Bool {
        if lhs.ids != rhs.ids { return false }
        if lhs.remainNum != rhs.remainNum { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_ChainInventory.BlockID + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_ChainInventory.BlockID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_ChainInventory.protoMessageName + ".BlockId"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "hash"),
        2: .same(proto: "number"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &hash)
            case 2: try decoder.decodeSingularInt64Field(value: &number)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !hash.isEmpty {
            try visitor.visitSingularBytesField(value: hash, fieldNumber: 1)
        }
        if number != 0 {
            try visitor.visitSingularInt64Field(value: number, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_ChainInventory.BlockID, rhs: Protocol_ChainInventory.BlockID) -> Bool {
        if lhs.hash != rhs.hash { return false }
        if lhs.number != rhs.number { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_BlockInventory + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_BlockInventory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".BlockInventory"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ids"),
        2: .same(proto: "type"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &ids)
            case 2: try decoder.decodeSingularEnumField(value: &type)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !ids.isEmpty {
            try visitor.visitRepeatedMessageField(value: ids, fieldNumber: 1)
        }
        if type != .sync {
            try visitor.visitSingularEnumField(value: type, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_BlockInventory, rhs: Protocol_BlockInventory) -> Bool {
        if lhs.ids != rhs.ids { return false }
        if lhs.type != rhs.type { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_BlockInventory.TypeEnum + SwiftProtobuf._ProtoNameProviding

extension Protocol_BlockInventory.TypeEnum: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "SYNC"),
        1: .same(proto: "ADVTISE"),
        2: .same(proto: "FETCH"),
    ]
}

// MARK: - Protocol_BlockInventory.BlockID + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_BlockInventory.BlockID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_BlockInventory.protoMessageName + ".BlockId"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "hash"),
        2: .same(proto: "number"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &hash)
            case 2: try decoder.decodeSingularInt64Field(value: &number)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !hash.isEmpty {
            try visitor.visitSingularBytesField(value: hash, fieldNumber: 1)
        }
        if number != 0 {
            try visitor.visitSingularInt64Field(value: number, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_BlockInventory.BlockID, rhs: Protocol_BlockInventory.BlockID) -> Bool {
        if lhs.hash != rhs.hash { return false }
        if lhs.number != rhs.number { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Inventory + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_Inventory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Inventory"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "ids"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &type)
            case 2: try decoder.decodeRepeatedBytesField(value: &ids)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if type != .trx {
            try visitor.visitSingularEnumField(value: type, fieldNumber: 1)
        }
        if !ids.isEmpty {
            try visitor.visitRepeatedBytesField(value: ids, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_Inventory, rhs: Protocol_Inventory) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.ids != rhs.ids { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Inventory.InventoryType + SwiftProtobuf._ProtoNameProviding

extension Protocol_Inventory.InventoryType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "TRX"),
        1: .same(proto: "BLOCK"),
    ]
}

// MARK: - Protocol_Items + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_Items: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Items"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "type"),
        2: .same(proto: "blocks"),
        3: .standard(proto: "block_headers"),
        4: .same(proto: "transactions"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &type)
            case 2: try decoder.decodeRepeatedMessageField(value: &blocks)
            case 3: try decoder.decodeRepeatedMessageField(value: &blockHeaders)
            case 4: try decoder.decodeRepeatedMessageField(value: &transactions)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if type != .err {
            try visitor.visitSingularEnumField(value: type, fieldNumber: 1)
        }
        if !blocks.isEmpty {
            try visitor.visitRepeatedMessageField(value: blocks, fieldNumber: 2)
        }
        if !blockHeaders.isEmpty {
            try visitor.visitRepeatedMessageField(value: blockHeaders, fieldNumber: 3)
        }
        if !transactions.isEmpty {
            try visitor.visitRepeatedMessageField(value: transactions, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_Items, rhs: Protocol_Items) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.blocks != rhs.blocks { return false }
        if lhs.blockHeaders != rhs.blockHeaders { return false }
        if lhs.transactions != rhs.transactions { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_Items.ItemType + SwiftProtobuf._ProtoNameProviding

extension Protocol_Items.ItemType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "ERR"),
        1: .same(proto: "TRX"),
        2: .same(proto: "BLOCK"),
        3: .same(proto: "BLOCKHEADER"),
    ]
}

// MARK: - Protocol_DynamicProperties + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_DynamicProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".DynamicProperties"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "last_solidity_block_num"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &lastSolidityBlockNum)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if lastSolidityBlockNum != 0 {
            try visitor.visitSingularInt64Field(value: lastSolidityBlockNum, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_DynamicProperties, rhs: Protocol_DynamicProperties) -> Bool {
        if lhs.lastSolidityBlockNum != rhs.lastSolidityBlockNum { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_DisconnectMessage + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_DisconnectMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".DisconnectMessage"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "reason"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &reason)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if reason != .requested {
            try visitor.visitSingularEnumField(value: reason, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_DisconnectMessage, rhs: Protocol_DisconnectMessage) -> Bool {
        if lhs.reason != rhs.reason { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_HelloMessage + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_HelloMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".HelloMessage"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "from"),
        2: .same(proto: "version"),
        3: .same(proto: "timestamp"),
        4: .same(proto: "genesisBlockId"),
        5: .same(proto: "solidBlockId"),
        6: .same(proto: "headBlockId"),
        7: .same(proto: "address"),
        8: .same(proto: "signature"),
        9: .same(proto: "nodeType"),
        10: .same(proto: "lowestBlockNum"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_from)
            case 2: try decoder.decodeSingularInt32Field(value: &version)
            case 3: try decoder.decodeSingularInt64Field(value: &timestamp)
            case 4: try decoder.decodeSingularMessageField(value: &_genesisBlockID)
            case 5: try decoder.decodeSingularMessageField(value: &_solidBlockID)
            case 6: try decoder.decodeSingularMessageField(value: &_headBlockID)
            case 7: try decoder.decodeSingularBytesField(value: &address)
            case 8: try decoder.decodeSingularBytesField(value: &signature)
            case 9: try decoder.decodeSingularInt32Field(value: &nodeType)
            case 10: try decoder.decodeSingularInt64Field(value: &lowestBlockNum)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _from {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if version != 0 {
            try visitor.visitSingularInt32Field(value: version, fieldNumber: 2)
        }
        if timestamp != 0 {
            try visitor.visitSingularInt64Field(value: timestamp, fieldNumber: 3)
        }
        try { if let v = self._genesisBlockID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try { if let v = self._solidBlockID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        } }()
        try { if let v = self._headBlockID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
        } }()
        if !address.isEmpty {
            try visitor.visitSingularBytesField(value: address, fieldNumber: 7)
        }
        if !signature.isEmpty {
            try visitor.visitSingularBytesField(value: signature, fieldNumber: 8)
        }
        if nodeType != 0 {
            try visitor.visitSingularInt32Field(value: nodeType, fieldNumber: 9)
        }
        if lowestBlockNum != 0 {
            try visitor.visitSingularInt64Field(value: lowestBlockNum, fieldNumber: 10)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_HelloMessage, rhs: Protocol_HelloMessage) -> Bool {
        if lhs._from != rhs._from { return false }
        if lhs.version != rhs.version { return false }
        if lhs.timestamp != rhs.timestamp { return false }
        if lhs._genesisBlockID != rhs._genesisBlockID { return false }
        if lhs._solidBlockID != rhs._solidBlockID { return false }
        if lhs._headBlockID != rhs._headBlockID { return false }
        if lhs.address != rhs.address { return false }
        if lhs.signature != rhs.signature { return false }
        if lhs.nodeType != rhs.nodeType { return false }
        if lhs.lowestBlockNum != rhs.lowestBlockNum { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_HelloMessage.BlockID + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_HelloMessage.BlockID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_HelloMessage.protoMessageName + ".BlockId"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "hash"),
        2: .same(proto: "number"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &hash)
            case 2: try decoder.decodeSingularInt64Field(value: &number)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !hash.isEmpty {
            try visitor.visitSingularBytesField(value: hash, fieldNumber: 1)
        }
        if number != 0 {
            try visitor.visitSingularInt64Field(value: number, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_HelloMessage.BlockID, rhs: Protocol_HelloMessage.BlockID) -> Bool {
        if lhs.hash != rhs.hash { return false }
        if lhs.number != rhs.number { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_InternalTransaction + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_InternalTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".InternalTransaction"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "hash"),
        2: .standard(proto: "caller_address"),
        3: .standard(proto: "transferTo_address"),
        4: .same(proto: "callValueInfo"),
        5: .same(proto: "note"),
        6: .same(proto: "rejected"),
        7: .same(proto: "extra"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &hash)
            case 2: try decoder.decodeSingularBytesField(value: &callerAddress)
            case 3: try decoder.decodeSingularBytesField(value: &transferToAddress)
            case 4: try decoder.decodeRepeatedMessageField(value: &callValueInfo)
            case 5: try decoder.decodeSingularBytesField(value: &note)
            case 6: try decoder.decodeSingularBoolField(value: &rejected)
            case 7: try decoder.decodeSingularStringField(value: &extra)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !hash.isEmpty {
            try visitor.visitSingularBytesField(value: hash, fieldNumber: 1)
        }
        if !callerAddress.isEmpty {
            try visitor.visitSingularBytesField(value: callerAddress, fieldNumber: 2)
        }
        if !transferToAddress.isEmpty {
            try visitor.visitSingularBytesField(value: transferToAddress, fieldNumber: 3)
        }
        if !callValueInfo.isEmpty {
            try visitor.visitRepeatedMessageField(value: callValueInfo, fieldNumber: 4)
        }
        if !note.isEmpty {
            try visitor.visitSingularBytesField(value: note, fieldNumber: 5)
        }
        if rejected != false {
            try visitor.visitSingularBoolField(value: rejected, fieldNumber: 6)
        }
        if !extra.isEmpty {
            try visitor.visitSingularStringField(value: extra, fieldNumber: 7)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_InternalTransaction, rhs: Protocol_InternalTransaction) -> Bool {
        if lhs.hash != rhs.hash { return false }
        if lhs.callerAddress != rhs.callerAddress { return false }
        if lhs.transferToAddress != rhs.transferToAddress { return false }
        if lhs.callValueInfo != rhs.callValueInfo { return false }
        if lhs.note != rhs.note { return false }
        if lhs.rejected != rhs.rejected { return false }
        if lhs.extra != rhs.extra { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_InternalTransaction.CallValueInfo + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_InternalTransaction.CallValueInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_InternalTransaction.protoMessageName + ".CallValueInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "callValue"),
        2: .same(proto: "tokenId"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &callValue)
            case 2: try decoder.decodeSingularStringField(value: &tokenID)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if callValue != 0 {
            try visitor.visitSingularInt64Field(value: callValue, fieldNumber: 1)
        }
        if !tokenID.isEmpty {
            try visitor.visitSingularStringField(value: tokenID, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_InternalTransaction.CallValueInfo, rhs: Protocol_InternalTransaction.CallValueInfo) -> Bool {
        if lhs.callValue != rhs.callValue { return false }
        if lhs.tokenID != rhs.tokenID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_DelegatedResourceAccountIndex + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_DelegatedResourceAccountIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".DelegatedResourceAccountIndex"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "account"),
        2: .same(proto: "fromAccounts"),
        3: .same(proto: "toAccounts"),
        4: .same(proto: "timestamp"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &account)
            case 2: try decoder.decodeRepeatedBytesField(value: &fromAccounts)
            case 3: try decoder.decodeRepeatedBytesField(value: &toAccounts)
            case 4: try decoder.decodeSingularInt64Field(value: &timestamp)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !account.isEmpty {
            try visitor.visitSingularBytesField(value: account, fieldNumber: 1)
        }
        if !fromAccounts.isEmpty {
            try visitor.visitRepeatedBytesField(value: fromAccounts, fieldNumber: 2)
        }
        if !toAccounts.isEmpty {
            try visitor.visitRepeatedBytesField(value: toAccounts, fieldNumber: 3)
        }
        if timestamp != 0 {
            try visitor.visitSingularInt64Field(value: timestamp, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_DelegatedResourceAccountIndex, rhs: Protocol_DelegatedResourceAccountIndex) -> Bool {
        if lhs.account != rhs.account { return false }
        if lhs.fromAccounts != rhs.fromAccounts { return false }
        if lhs.toAccounts != rhs.toAccounts { return false }
        if lhs.timestamp != rhs.timestamp { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_NodeInfo + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_NodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".NodeInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "beginSyncNum"),
        2: .same(proto: "block"),
        3: .same(proto: "solidityBlock"),
        4: .same(proto: "currentConnectCount"),
        5: .same(proto: "activeConnectCount"),
        6: .same(proto: "passiveConnectCount"),
        7: .same(proto: "totalFlow"),
        8: .same(proto: "peerInfoList"),
        9: .same(proto: "configNodeInfo"),
        10: .same(proto: "machineInfo"),
        11: .same(proto: "cheatWitnessInfoMap"),
    ]

    fileprivate class _StorageClass {
        var _beginSyncNum: Int64 = 0
        var _block: String = .init()
        var _solidityBlock: String = .init()
        var _currentConnectCount: Int32 = 0
        var _activeConnectCount: Int32 = 0
        var _passiveConnectCount: Int32 = 0
        var _totalFlow: Int64 = 0
        var _peerInfoList: [Protocol_NodeInfo.PeerInfo] = []
        var _configNodeInfo: Protocol_NodeInfo.ConfigNodeInfo? = nil
        var _machineInfo: Protocol_NodeInfo.MachineInfo? = nil
        var _cheatWitnessInfoMap: [String: String] = [:]

        static let defaultInstance = _StorageClass()

        private init() { }

        init(copying source: _StorageClass) {
            _beginSyncNum = source._beginSyncNum
            _block = source._block
            _solidityBlock = source._solidityBlock
            _currentConnectCount = source._currentConnectCount
            _activeConnectCount = source._activeConnectCount
            _passiveConnectCount = source._passiveConnectCount
            _totalFlow = source._totalFlow
            _peerInfoList = source._peerInfoList
            _configNodeInfo = source._configNodeInfo
            _machineInfo = source._machineInfo
            _cheatWitnessInfoMap = source._cheatWitnessInfoMap
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularInt64Field(value: &_storage._beginSyncNum)

                case 2: try decoder.decodeSingularStringField(value: &_storage._block)

                case 3: try decoder.decodeSingularStringField(value: &_storage._solidityBlock)

                case 4: try decoder.decodeSingularInt32Field(value: &_storage._currentConnectCount)

                case 5: try decoder.decodeSingularInt32Field(value: &_storage._activeConnectCount)

                case 6: try decoder.decodeSingularInt32Field(value: &_storage._passiveConnectCount)

                case 7: try decoder.decodeSingularInt64Field(value: &_storage._totalFlow)

                case 8: try decoder.decodeRepeatedMessageField(value: &_storage._peerInfoList)

                case 9: try decoder.decodeSingularMessageField(value: &_storage._configNodeInfo)

                case 10: try decoder.decodeSingularMessageField(value: &_storage._machineInfo)

                case 11: try decoder.decodeMapField(
                        fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                        value: &_storage._cheatWitnessInfoMap
                    )

                default: break
                }
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            if _storage._beginSyncNum != 0 {
                try visitor.visitSingularInt64Field(value: _storage._beginSyncNum, fieldNumber: 1)
            }
            if !_storage._block.isEmpty {
                try visitor.visitSingularStringField(value: _storage._block, fieldNumber: 2)
            }
            if !_storage._solidityBlock.isEmpty {
                try visitor.visitSingularStringField(value: _storage._solidityBlock, fieldNumber: 3)
            }
            if _storage._currentConnectCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._currentConnectCount, fieldNumber: 4)
            }
            if _storage._activeConnectCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._activeConnectCount, fieldNumber: 5)
            }
            if _storage._passiveConnectCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._passiveConnectCount, fieldNumber: 6)
            }
            if _storage._totalFlow != 0 {
                try visitor.visitSingularInt64Field(value: _storage._totalFlow, fieldNumber: 7)
            }
            if !_storage._peerInfoList.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._peerInfoList, fieldNumber: 8)
            }
            try { if let v = _storage._configNodeInfo {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
            } }()
            try { if let v = _storage._machineInfo {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
            } }()
            if !_storage._cheatWitnessInfoMap.isEmpty {
                try visitor.visitMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                    value: _storage._cheatWitnessInfoMap,
                    fieldNumber: 11
                )
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_NodeInfo, rhs: Protocol_NodeInfo) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((
                lhs._storage,
                rhs._storage
            )) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._beginSyncNum != rhs_storage._beginSyncNum { return false }
                if _storage._block != rhs_storage._block { return false }
                if _storage._solidityBlock != rhs_storage._solidityBlock { return false }
                if _storage._currentConnectCount != rhs_storage._currentConnectCount { return false }
                if _storage._activeConnectCount != rhs_storage._activeConnectCount { return false }
                if _storage._passiveConnectCount != rhs_storage._passiveConnectCount { return false }
                if _storage._totalFlow != rhs_storage._totalFlow { return false }
                if _storage._peerInfoList != rhs_storage._peerInfoList { return false }
                if _storage._configNodeInfo != rhs_storage._configNodeInfo { return false }
                if _storage._machineInfo != rhs_storage._machineInfo { return false }
                if _storage._cheatWitnessInfoMap != rhs_storage._cheatWitnessInfoMap { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_NodeInfo.PeerInfo + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_NodeInfo.PeerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_NodeInfo.protoMessageName + ".PeerInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "lastSyncBlock"),
        2: .same(proto: "remainNum"),
        3: .same(proto: "lastBlockUpdateTime"),
        4: .same(proto: "syncFlag"),
        5: .same(proto: "headBlockTimeWeBothHave"),
        6: .same(proto: "needSyncFromPeer"),
        7: .same(proto: "needSyncFromUs"),
        8: .same(proto: "host"),
        9: .same(proto: "port"),
        10: .same(proto: "nodeId"),
        11: .same(proto: "connectTime"),
        12: .same(proto: "avgLatency"),
        13: .same(proto: "syncToFetchSize"),
        14: .same(proto: "syncToFetchSizePeekNum"),
        15: .same(proto: "syncBlockRequestedSize"),
        16: .same(proto: "unFetchSynNum"),
        17: .same(proto: "blockInPorcSize"),
        18: .same(proto: "headBlockWeBothHave"),
        19: .same(proto: "isActive"),
        20: .same(proto: "score"),
        21: .same(proto: "nodeCount"),
        22: .same(proto: "inFlow"),
        23: .same(proto: "disconnectTimes"),
        24: .same(proto: "localDisconnectReason"),
        25: .same(proto: "remoteDisconnectReason"),
    ]

    fileprivate class _StorageClass {
        var _lastSyncBlock: String = .init()
        var _remainNum: Int64 = 0
        var _lastBlockUpdateTime: Int64 = 0
        var _syncFlag = false
        var _headBlockTimeWeBothHave: Int64 = 0
        var _needSyncFromPeer = false
        var _needSyncFromUs = false
        var _host: String = .init()
        var _port: Int32 = 0
        var _nodeID: String = .init()
        var _connectTime: Int64 = 0
        var _avgLatency: Double = 0
        var _syncToFetchSize: Int32 = 0
        var _syncToFetchSizePeekNum: Int64 = 0
        var _syncBlockRequestedSize: Int32 = 0
        var _unFetchSynNum: Int64 = 0
        var _blockInPorcSize: Int32 = 0
        var _headBlockWeBothHave: String = .init()
        var _isActive = false
        var _score: Int32 = 0
        var _nodeCount: Int32 = 0
        var _inFlow: Int64 = 0
        var _disconnectTimes: Int32 = 0
        var _localDisconnectReason: String = .init()
        var _remoteDisconnectReason: String = .init()

        static let defaultInstance = _StorageClass()

        private init() { }

        init(copying source: _StorageClass) {
            _lastSyncBlock = source._lastSyncBlock
            _remainNum = source._remainNum
            _lastBlockUpdateTime = source._lastBlockUpdateTime
            _syncFlag = source._syncFlag
            _headBlockTimeWeBothHave = source._headBlockTimeWeBothHave
            _needSyncFromPeer = source._needSyncFromPeer
            _needSyncFromUs = source._needSyncFromUs
            _host = source._host
            _port = source._port
            _nodeID = source._nodeID
            _connectTime = source._connectTime
            _avgLatency = source._avgLatency
            _syncToFetchSize = source._syncToFetchSize
            _syncToFetchSizePeekNum = source._syncToFetchSizePeekNum
            _syncBlockRequestedSize = source._syncBlockRequestedSize
            _unFetchSynNum = source._unFetchSynNum
            _blockInPorcSize = source._blockInPorcSize
            _headBlockWeBothHave = source._headBlockWeBothHave
            _isActive = source._isActive
            _score = source._score
            _nodeCount = source._nodeCount
            _inFlow = source._inFlow
            _disconnectTimes = source._disconnectTimes
            _localDisconnectReason = source._localDisconnectReason
            _remoteDisconnectReason = source._remoteDisconnectReason
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularStringField(value: &_storage._lastSyncBlock)
                case 2: try decoder.decodeSingularInt64Field(value: &_storage._remainNum)
                case 3: try decoder.decodeSingularInt64Field(value: &_storage._lastBlockUpdateTime)
                case 4: try decoder.decodeSingularBoolField(value: &_storage._syncFlag)
                case 5: try decoder.decodeSingularInt64Field(value: &_storage._headBlockTimeWeBothHave)
                case 6: try decoder.decodeSingularBoolField(value: &_storage._needSyncFromPeer)
                case 7: try decoder.decodeSingularBoolField(value: &_storage._needSyncFromUs)
                case 8: try decoder.decodeSingularStringField(value: &_storage._host)
                case 9: try decoder.decodeSingularInt32Field(value: &_storage._port)
                case 10: try decoder.decodeSingularStringField(value: &_storage._nodeID)
                case 11: try decoder.decodeSingularInt64Field(value: &_storage._connectTime)
                case 12: try decoder.decodeSingularDoubleField(value: &_storage._avgLatency)
                case 13: try decoder.decodeSingularInt32Field(value: &_storage._syncToFetchSize)
                case 14: try decoder.decodeSingularInt64Field(value: &_storage._syncToFetchSizePeekNum)
                case 15: try decoder.decodeSingularInt32Field(value: &_storage._syncBlockRequestedSize)
                case 16: try decoder.decodeSingularInt64Field(value: &_storage._unFetchSynNum)
                case 17: try decoder.decodeSingularInt32Field(value: &_storage._blockInPorcSize)
                case 18: try decoder.decodeSingularStringField(value: &_storage._headBlockWeBothHave)
                case 19: try decoder.decodeSingularBoolField(value: &_storage._isActive)
                case 20: try decoder.decodeSingularInt32Field(value: &_storage._score)
                case 21: try decoder.decodeSingularInt32Field(value: &_storage._nodeCount)
                case 22: try decoder.decodeSingularInt64Field(value: &_storage._inFlow)
                case 23: try decoder.decodeSingularInt32Field(value: &_storage._disconnectTimes)
                case 24: try decoder.decodeSingularStringField(value: &_storage._localDisconnectReason)
                case 25: try decoder.decodeSingularStringField(value: &_storage._remoteDisconnectReason)
                default: break
                }
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if !_storage._lastSyncBlock.isEmpty {
                try visitor.visitSingularStringField(value: _storage._lastSyncBlock, fieldNumber: 1)
            }
            if _storage._remainNum != 0 {
                try visitor.visitSingularInt64Field(value: _storage._remainNum, fieldNumber: 2)
            }
            if _storage._lastBlockUpdateTime != 0 {
                try visitor.visitSingularInt64Field(value: _storage._lastBlockUpdateTime, fieldNumber: 3)
            }
            if _storage._syncFlag != false {
                try visitor.visitSingularBoolField(value: _storage._syncFlag, fieldNumber: 4)
            }
            if _storage._headBlockTimeWeBothHave != 0 {
                try visitor.visitSingularInt64Field(value: _storage._headBlockTimeWeBothHave, fieldNumber: 5)
            }
            if _storage._needSyncFromPeer != false {
                try visitor.visitSingularBoolField(value: _storage._needSyncFromPeer, fieldNumber: 6)
            }
            if _storage._needSyncFromUs != false {
                try visitor.visitSingularBoolField(value: _storage._needSyncFromUs, fieldNumber: 7)
            }
            if !_storage._host.isEmpty {
                try visitor.visitSingularStringField(value: _storage._host, fieldNumber: 8)
            }
            if _storage._port != 0 {
                try visitor.visitSingularInt32Field(value: _storage._port, fieldNumber: 9)
            }
            if !_storage._nodeID.isEmpty {
                try visitor.visitSingularStringField(value: _storage._nodeID, fieldNumber: 10)
            }
            if _storage._connectTime != 0 {
                try visitor.visitSingularInt64Field(value: _storage._connectTime, fieldNumber: 11)
            }
            if _storage._avgLatency != 0 {
                try visitor.visitSingularDoubleField(value: _storage._avgLatency, fieldNumber: 12)
            }
            if _storage._syncToFetchSize != 0 {
                try visitor.visitSingularInt32Field(value: _storage._syncToFetchSize, fieldNumber: 13)
            }
            if _storage._syncToFetchSizePeekNum != 0 {
                try visitor.visitSingularInt64Field(value: _storage._syncToFetchSizePeekNum, fieldNumber: 14)
            }
            if _storage._syncBlockRequestedSize != 0 {
                try visitor.visitSingularInt32Field(value: _storage._syncBlockRequestedSize, fieldNumber: 15)
            }
            if _storage._unFetchSynNum != 0 {
                try visitor.visitSingularInt64Field(value: _storage._unFetchSynNum, fieldNumber: 16)
            }
            if _storage._blockInPorcSize != 0 {
                try visitor.visitSingularInt32Field(value: _storage._blockInPorcSize, fieldNumber: 17)
            }
            if !_storage._headBlockWeBothHave.isEmpty {
                try visitor.visitSingularStringField(value: _storage._headBlockWeBothHave, fieldNumber: 18)
            }
            if _storage._isActive != false {
                try visitor.visitSingularBoolField(value: _storage._isActive, fieldNumber: 19)
            }
            if _storage._score != 0 {
                try visitor.visitSingularInt32Field(value: _storage._score, fieldNumber: 20)
            }
            if _storage._nodeCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._nodeCount, fieldNumber: 21)
            }
            if _storage._inFlow != 0 {
                try visitor.visitSingularInt64Field(value: _storage._inFlow, fieldNumber: 22)
            }
            if _storage._disconnectTimes != 0 {
                try visitor.visitSingularInt32Field(value: _storage._disconnectTimes, fieldNumber: 23)
            }
            if !_storage._localDisconnectReason.isEmpty {
                try visitor.visitSingularStringField(value: _storage._localDisconnectReason, fieldNumber: 24)
            }
            if !_storage._remoteDisconnectReason.isEmpty {
                try visitor.visitSingularStringField(value: _storage._remoteDisconnectReason, fieldNumber: 25)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_NodeInfo.PeerInfo, rhs: Protocol_NodeInfo.PeerInfo) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((
                lhs._storage,
                rhs._storage
            )) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._lastSyncBlock != rhs_storage._lastSyncBlock { return false }
                if _storage._remainNum != rhs_storage._remainNum { return false }
                if _storage._lastBlockUpdateTime != rhs_storage._lastBlockUpdateTime { return false }
                if _storage._syncFlag != rhs_storage._syncFlag { return false }
                if _storage._headBlockTimeWeBothHave != rhs_storage._headBlockTimeWeBothHave { return false }
                if _storage._needSyncFromPeer != rhs_storage._needSyncFromPeer { return false }
                if _storage._needSyncFromUs != rhs_storage._needSyncFromUs { return false }
                if _storage._host != rhs_storage._host { return false }
                if _storage._port != rhs_storage._port { return false }
                if _storage._nodeID != rhs_storage._nodeID { return false }
                if _storage._connectTime != rhs_storage._connectTime { return false }
                if _storage._avgLatency != rhs_storage._avgLatency { return false }
                if _storage._syncToFetchSize != rhs_storage._syncToFetchSize { return false }
                if _storage._syncToFetchSizePeekNum != rhs_storage._syncToFetchSizePeekNum { return false }
                if _storage._syncBlockRequestedSize != rhs_storage._syncBlockRequestedSize { return false }
                if _storage._unFetchSynNum != rhs_storage._unFetchSynNum { return false }
                if _storage._blockInPorcSize != rhs_storage._blockInPorcSize { return false }
                if _storage._headBlockWeBothHave != rhs_storage._headBlockWeBothHave { return false }
                if _storage._isActive != rhs_storage._isActive { return false }
                if _storage._score != rhs_storage._score { return false }
                if _storage._nodeCount != rhs_storage._nodeCount { return false }
                if _storage._inFlow != rhs_storage._inFlow { return false }
                if _storage._disconnectTimes != rhs_storage._disconnectTimes { return false }
                if _storage._localDisconnectReason != rhs_storage._localDisconnectReason { return false }
                if _storage._remoteDisconnectReason != rhs_storage._remoteDisconnectReason { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_NodeInfo.ConfigNodeInfo + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_NodeInfo.ConfigNodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_NodeInfo.protoMessageName + ".ConfigNodeInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "codeVersion"),
        2: .same(proto: "p2pVersion"),
        3: .same(proto: "listenPort"),
        4: .same(proto: "discoverEnable"),
        5: .same(proto: "activeNodeSize"),
        6: .same(proto: "passiveNodeSize"),
        7: .same(proto: "sendNodeSize"),
        8: .same(proto: "maxConnectCount"),
        9: .same(proto: "sameIpMaxConnectCount"),
        10: .same(proto: "backupListenPort"),
        11: .same(proto: "backupMemberSize"),
        12: .same(proto: "backupPriority"),
        13: .same(proto: "dbVersion"),
        14: .same(proto: "minParticipationRate"),
        15: .same(proto: "supportConstant"),
        16: .same(proto: "minTimeRatio"),
        17: .same(proto: "maxTimeRatio"),
        18: .same(proto: "allowCreationOfContracts"),
        19: .same(proto: "allowAdaptiveEnergy"),
    ]

    fileprivate class _StorageClass {
        var _codeVersion: String = .init()
        var _p2PVersion: String = .init()
        var _listenPort: Int32 = 0
        var _discoverEnable = false
        var _activeNodeSize: Int32 = 0
        var _passiveNodeSize: Int32 = 0
        var _sendNodeSize: Int32 = 0
        var _maxConnectCount: Int32 = 0
        var _sameIpMaxConnectCount: Int32 = 0
        var _backupListenPort: Int32 = 0
        var _backupMemberSize: Int32 = 0
        var _backupPriority: Int32 = 0
        var _dbVersion: Int32 = 0
        var _minParticipationRate: Int32 = 0
        var _supportConstant = false
        var _minTimeRatio: Double = 0
        var _maxTimeRatio: Double = 0
        var _allowCreationOfContracts: Int64 = 0
        var _allowAdaptiveEnergy: Int64 = 0

        static let defaultInstance = _StorageClass()

        private init() { }

        init(copying source: _StorageClass) {
            _codeVersion = source._codeVersion
            _p2PVersion = source._p2PVersion
            _listenPort = source._listenPort
            _discoverEnable = source._discoverEnable
            _activeNodeSize = source._activeNodeSize
            _passiveNodeSize = source._passiveNodeSize
            _sendNodeSize = source._sendNodeSize
            _maxConnectCount = source._maxConnectCount
            _sameIpMaxConnectCount = source._sameIpMaxConnectCount
            _backupListenPort = source._backupListenPort
            _backupMemberSize = source._backupMemberSize
            _backupPriority = source._backupPriority
            _dbVersion = source._dbVersion
            _minParticipationRate = source._minParticipationRate
            _supportConstant = source._supportConstant
            _minTimeRatio = source._minTimeRatio
            _maxTimeRatio = source._maxTimeRatio
            _allowCreationOfContracts = source._allowCreationOfContracts
            _allowAdaptiveEnergy = source._allowAdaptiveEnergy
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularStringField(value: &_storage._codeVersion)
                case 2: try decoder.decodeSingularStringField(value: &_storage._p2PVersion)
                case 3: try decoder.decodeSingularInt32Field(value: &_storage._listenPort)
                case 4: try decoder.decodeSingularBoolField(value: &_storage._discoverEnable)
                case 5: try decoder.decodeSingularInt32Field(value: &_storage._activeNodeSize)
                case 6: try decoder.decodeSingularInt32Field(value: &_storage._passiveNodeSize)
                case 7: try decoder.decodeSingularInt32Field(value: &_storage._sendNodeSize)
                case 8: try decoder.decodeSingularInt32Field(value: &_storage._maxConnectCount)
                case 9: try decoder.decodeSingularInt32Field(value: &_storage._sameIpMaxConnectCount)
                case 10: try decoder.decodeSingularInt32Field(value: &_storage._backupListenPort)
                case 11: try decoder.decodeSingularInt32Field(value: &_storage._backupMemberSize)
                case 12: try decoder.decodeSingularInt32Field(value: &_storage._backupPriority)
                case 13: try decoder.decodeSingularInt32Field(value: &_storage._dbVersion)
                case 14: try decoder.decodeSingularInt32Field(value: &_storage._minParticipationRate)
                case 15: try decoder.decodeSingularBoolField(value: &_storage._supportConstant)
                case 16: try decoder.decodeSingularDoubleField(value: &_storage._minTimeRatio)
                case 17: try decoder.decodeSingularDoubleField(value: &_storage._maxTimeRatio)
                case 18: try decoder.decodeSingularInt64Field(value: &_storage._allowCreationOfContracts)
                case 19: try decoder.decodeSingularInt64Field(value: &_storage._allowAdaptiveEnergy)
                default: break
                }
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            if !_storage._codeVersion.isEmpty {
                try visitor.visitSingularStringField(value: _storage._codeVersion, fieldNumber: 1)
            }
            if !_storage._p2PVersion.isEmpty {
                try visitor.visitSingularStringField(value: _storage._p2PVersion, fieldNumber: 2)
            }
            if _storage._listenPort != 0 {
                try visitor.visitSingularInt32Field(value: _storage._listenPort, fieldNumber: 3)
            }
            if _storage._discoverEnable != false {
                try visitor.visitSingularBoolField(value: _storage._discoverEnable, fieldNumber: 4)
            }
            if _storage._activeNodeSize != 0 {
                try visitor.visitSingularInt32Field(value: _storage._activeNodeSize, fieldNumber: 5)
            }
            if _storage._passiveNodeSize != 0 {
                try visitor.visitSingularInt32Field(value: _storage._passiveNodeSize, fieldNumber: 6)
            }
            if _storage._sendNodeSize != 0 {
                try visitor.visitSingularInt32Field(value: _storage._sendNodeSize, fieldNumber: 7)
            }
            if _storage._maxConnectCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._maxConnectCount, fieldNumber: 8)
            }
            if _storage._sameIpMaxConnectCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._sameIpMaxConnectCount, fieldNumber: 9)
            }
            if _storage._backupListenPort != 0 {
                try visitor.visitSingularInt32Field(value: _storage._backupListenPort, fieldNumber: 10)
            }
            if _storage._backupMemberSize != 0 {
                try visitor.visitSingularInt32Field(value: _storage._backupMemberSize, fieldNumber: 11)
            }
            if _storage._backupPriority != 0 {
                try visitor.visitSingularInt32Field(value: _storage._backupPriority, fieldNumber: 12)
            }
            if _storage._dbVersion != 0 {
                try visitor.visitSingularInt32Field(value: _storage._dbVersion, fieldNumber: 13)
            }
            if _storage._minParticipationRate != 0 {
                try visitor.visitSingularInt32Field(value: _storage._minParticipationRate, fieldNumber: 14)
            }
            if _storage._supportConstant != false {
                try visitor.visitSingularBoolField(value: _storage._supportConstant, fieldNumber: 15)
            }
            if _storage._minTimeRatio != 0 {
                try visitor.visitSingularDoubleField(value: _storage._minTimeRatio, fieldNumber: 16)
            }
            if _storage._maxTimeRatio != 0 {
                try visitor.visitSingularDoubleField(value: _storage._maxTimeRatio, fieldNumber: 17)
            }
            if _storage._allowCreationOfContracts != 0 {
                try visitor.visitSingularInt64Field(value: _storage._allowCreationOfContracts, fieldNumber: 18)
            }
            if _storage._allowAdaptiveEnergy != 0 {
                try visitor.visitSingularInt64Field(value: _storage._allowAdaptiveEnergy, fieldNumber: 19)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_NodeInfo.ConfigNodeInfo, rhs: Protocol_NodeInfo.ConfigNodeInfo) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((
                lhs._storage,
                rhs._storage
            )) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._codeVersion != rhs_storage._codeVersion { return false }
                if _storage._p2PVersion != rhs_storage._p2PVersion { return false }
                if _storage._listenPort != rhs_storage._listenPort { return false }
                if _storage._discoverEnable != rhs_storage._discoverEnable { return false }
                if _storage._activeNodeSize != rhs_storage._activeNodeSize { return false }
                if _storage._passiveNodeSize != rhs_storage._passiveNodeSize { return false }
                if _storage._sendNodeSize != rhs_storage._sendNodeSize { return false }
                if _storage._maxConnectCount != rhs_storage._maxConnectCount { return false }
                if _storage._sameIpMaxConnectCount != rhs_storage._sameIpMaxConnectCount { return false }
                if _storage._backupListenPort != rhs_storage._backupListenPort { return false }
                if _storage._backupMemberSize != rhs_storage._backupMemberSize { return false }
                if _storage._backupPriority != rhs_storage._backupPriority { return false }
                if _storage._dbVersion != rhs_storage._dbVersion { return false }
                if _storage._minParticipationRate != rhs_storage._minParticipationRate { return false }
                if _storage._supportConstant != rhs_storage._supportConstant { return false }
                if _storage._minTimeRatio != rhs_storage._minTimeRatio { return false }
                if _storage._maxTimeRatio != rhs_storage._maxTimeRatio { return false }
                if _storage._allowCreationOfContracts != rhs_storage._allowCreationOfContracts { return false }
                if _storage._allowAdaptiveEnergy != rhs_storage._allowAdaptiveEnergy { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_NodeInfo.MachineInfo + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_NodeInfo.MachineInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_NodeInfo.protoMessageName + ".MachineInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "threadCount"),
        2: .same(proto: "deadLockThreadCount"),
        3: .same(proto: "cpuCount"),
        4: .same(proto: "totalMemory"),
        5: .same(proto: "freeMemory"),
        6: .same(proto: "cpuRate"),
        7: .same(proto: "javaVersion"),
        8: .same(proto: "osName"),
        9: .same(proto: "jvmTotalMemory"),
        10: .same(proto: "jvmFreeMemory"),
        11: .same(proto: "processCpuRate"),
        12: .same(proto: "memoryDescInfoList"),
        13: .same(proto: "deadLockThreadInfoList"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt32Field(value: &threadCount)
            case 2: try decoder.decodeSingularInt32Field(value: &deadLockThreadCount)
            case 3: try decoder.decodeSingularInt32Field(value: &cpuCount)
            case 4: try decoder.decodeSingularInt64Field(value: &totalMemory)
            case 5: try decoder.decodeSingularInt64Field(value: &freeMemory)
            case 6: try decoder.decodeSingularDoubleField(value: &cpuRate)
            case 7: try decoder.decodeSingularStringField(value: &javaVersion)
            case 8: try decoder.decodeSingularStringField(value: &osName)
            case 9: try decoder.decodeSingularInt64Field(value: &jvmTotalMemory)
            case 10: try decoder.decodeSingularInt64Field(value: &jvmFreeMemory)
            case 11: try decoder.decodeSingularDoubleField(value: &processCpuRate)
            case 12: try decoder.decodeRepeatedMessageField(value: &memoryDescInfoList)
            case 13: try decoder.decodeRepeatedMessageField(value: &deadLockThreadInfoList)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if threadCount != 0 {
            try visitor.visitSingularInt32Field(value: threadCount, fieldNumber: 1)
        }
        if deadLockThreadCount != 0 {
            try visitor.visitSingularInt32Field(value: deadLockThreadCount, fieldNumber: 2)
        }
        if cpuCount != 0 {
            try visitor.visitSingularInt32Field(value: cpuCount, fieldNumber: 3)
        }
        if totalMemory != 0 {
            try visitor.visitSingularInt64Field(value: totalMemory, fieldNumber: 4)
        }
        if freeMemory != 0 {
            try visitor.visitSingularInt64Field(value: freeMemory, fieldNumber: 5)
        }
        if cpuRate != 0 {
            try visitor.visitSingularDoubleField(value: cpuRate, fieldNumber: 6)
        }
        if !javaVersion.isEmpty {
            try visitor.visitSingularStringField(value: javaVersion, fieldNumber: 7)
        }
        if !osName.isEmpty {
            try visitor.visitSingularStringField(value: osName, fieldNumber: 8)
        }
        if jvmTotalMemory != 0 {
            try visitor.visitSingularInt64Field(value: jvmTotalMemory, fieldNumber: 9)
        }
        if jvmFreeMemory != 0 {
            try visitor.visitSingularInt64Field(value: jvmFreeMemory, fieldNumber: 10)
        }
        if processCpuRate != 0 {
            try visitor.visitSingularDoubleField(value: processCpuRate, fieldNumber: 11)
        }
        if !memoryDescInfoList.isEmpty {
            try visitor.visitRepeatedMessageField(value: memoryDescInfoList, fieldNumber: 12)
        }
        if !deadLockThreadInfoList.isEmpty {
            try visitor.visitRepeatedMessageField(value: deadLockThreadInfoList, fieldNumber: 13)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_NodeInfo.MachineInfo, rhs: Protocol_NodeInfo.MachineInfo) -> Bool {
        if lhs.threadCount != rhs.threadCount { return false }
        if lhs.deadLockThreadCount != rhs.deadLockThreadCount { return false }
        if lhs.cpuCount != rhs.cpuCount { return false }
        if lhs.totalMemory != rhs.totalMemory { return false }
        if lhs.freeMemory != rhs.freeMemory { return false }
        if lhs.cpuRate != rhs.cpuRate { return false }
        if lhs.javaVersion != rhs.javaVersion { return false }
        if lhs.osName != rhs.osName { return false }
        if lhs.jvmTotalMemory != rhs.jvmTotalMemory { return false }
        if lhs.jvmFreeMemory != rhs.jvmFreeMemory { return false }
        if lhs.processCpuRate != rhs.processCpuRate { return false }
        if lhs.memoryDescInfoList != rhs.memoryDescInfoList { return false }
        if lhs.deadLockThreadInfoList != rhs.deadLockThreadInfoList { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_NodeInfo.MachineInfo.MemoryDescInfo + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_NodeInfo.MachineInfo.MemoryDescInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_NodeInfo.MachineInfo.protoMessageName + ".MemoryDescInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .same(proto: "initSize"),
        3: .same(proto: "useSize"),
        4: .same(proto: "maxSize"),
        5: .same(proto: "useRate"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularInt64Field(value: &initSize)
            case 3: try decoder.decodeSingularInt64Field(value: &useSize)
            case 4: try decoder.decodeSingularInt64Field(value: &maxSize)
            case 5: try decoder.decodeSingularDoubleField(value: &useRate)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if initSize != 0 {
            try visitor.visitSingularInt64Field(value: initSize, fieldNumber: 2)
        }
        if useSize != 0 {
            try visitor.visitSingularInt64Field(value: useSize, fieldNumber: 3)
        }
        if maxSize != 0 {
            try visitor.visitSingularInt64Field(value: maxSize, fieldNumber: 4)
        }
        if useRate != 0 {
            try visitor.visitSingularDoubleField(value: useRate, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Protocol_NodeInfo.MachineInfo.MemoryDescInfo,
        rhs: Protocol_NodeInfo.MachineInfo.MemoryDescInfo
    ) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.initSize != rhs.initSize { return false }
        if lhs.useSize != rhs.useSize { return false }
        if lhs.maxSize != rhs.maxSize { return false }
        if lhs.useRate != rhs.useRate { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_NodeInfo.MachineInfo.DeadLockThreadInfo + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_NodeInfo.MachineInfo.DeadLockThreadInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_NodeInfo.MachineInfo.protoMessageName + ".DeadLockThreadInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .same(proto: "lockName"),
        3: .same(proto: "lockOwner"),
        4: .same(proto: "state"),
        5: .same(proto: "blockTime"),
        6: .same(proto: "waitTime"),
        7: .same(proto: "stackTrace"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularStringField(value: &lockName)
            case 3: try decoder.decodeSingularStringField(value: &lockOwner)
            case 4: try decoder.decodeSingularStringField(value: &state)
            case 5: try decoder.decodeSingularInt64Field(value: &blockTime)
            case 6: try decoder.decodeSingularInt64Field(value: &waitTime)
            case 7: try decoder.decodeSingularStringField(value: &stackTrace)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if !lockName.isEmpty {
            try visitor.visitSingularStringField(value: lockName, fieldNumber: 2)
        }
        if !lockOwner.isEmpty {
            try visitor.visitSingularStringField(value: lockOwner, fieldNumber: 3)
        }
        if !state.isEmpty {
            try visitor.visitSingularStringField(value: state, fieldNumber: 4)
        }
        if blockTime != 0 {
            try visitor.visitSingularInt64Field(value: blockTime, fieldNumber: 5)
        }
        if waitTime != 0 {
            try visitor.visitSingularInt64Field(value: waitTime, fieldNumber: 6)
        }
        if !stackTrace.isEmpty {
            try visitor.visitSingularStringField(value: stackTrace, fieldNumber: 7)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Protocol_NodeInfo.MachineInfo.DeadLockThreadInfo,
        rhs: Protocol_NodeInfo.MachineInfo.DeadLockThreadInfo
    ) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.lockName != rhs.lockName { return false }
        if lhs.lockOwner != rhs.lockOwner { return false }
        if lhs.state != rhs.state { return false }
        if lhs.blockTime != rhs.blockTime { return false }
        if lhs.waitTime != rhs.waitTime { return false }
        if lhs.stackTrace != rhs.stackTrace { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MetricsInfo + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MetricsInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".MetricsInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "interval"),
        2: .same(proto: "node"),
        3: .same(proto: "blockchain"),
        4: .same(proto: "net"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &interval)
            case 2: try decoder.decodeSingularMessageField(value: &_node)
            case 3: try decoder.decodeSingularMessageField(value: &_blockchain)
            case 4: try decoder.decodeSingularMessageField(value: &_net)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if interval != 0 {
            try visitor.visitSingularInt64Field(value: interval, fieldNumber: 1)
        }
        try { if let v = self._node {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._blockchain {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._net {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_MetricsInfo, rhs: Protocol_MetricsInfo) -> Bool {
        if lhs.interval != rhs.interval { return false }
        if lhs._node != rhs._node { return false }
        if lhs._blockchain != rhs._blockchain { return false }
        if lhs._net != rhs._net { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MetricsInfo.NodeInfo + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MetricsInfo.NodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_MetricsInfo.protoMessageName + ".NodeInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ip"),
        2: .same(proto: "nodeType"),
        3: .same(proto: "version"),
        4: .same(proto: "backupStatus"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &ip)
            case 2: try decoder.decodeSingularInt32Field(value: &nodeType)
            case 3: try decoder.decodeSingularStringField(value: &version)
            case 4: try decoder.decodeSingularInt32Field(value: &backupStatus)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !ip.isEmpty {
            try visitor.visitSingularStringField(value: ip, fieldNumber: 1)
        }
        if nodeType != 0 {
            try visitor.visitSingularInt32Field(value: nodeType, fieldNumber: 2)
        }
        if !version.isEmpty {
            try visitor.visitSingularStringField(value: version, fieldNumber: 3)
        }
        if backupStatus != 0 {
            try visitor.visitSingularInt32Field(value: backupStatus, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_MetricsInfo.NodeInfo, rhs: Protocol_MetricsInfo.NodeInfo) -> Bool {
        if lhs.ip != rhs.ip { return false }
        if lhs.nodeType != rhs.nodeType { return false }
        if lhs.version != rhs.version { return false }
        if lhs.backupStatus != rhs.backupStatus { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MetricsInfo.BlockChainInfo + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MetricsInfo.BlockChainInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_MetricsInfo.protoMessageName + ".BlockChainInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "headBlockNum"),
        2: .same(proto: "headBlockTimestamp"),
        3: .same(proto: "headBlockHash"),
        4: .same(proto: "forkCount"),
        5: .same(proto: "failForkCount"),
        6: .same(proto: "blockProcessTime"),
        7: .same(proto: "tps"),
        8: .same(proto: "transactionCacheSize"),
        9: .same(proto: "missedTransaction"),
        10: .same(proto: "witnesses"),
        11: .same(proto: "failProcessBlockNum"),
        12: .same(proto: "failProcessBlockReason"),
        13: .same(proto: "dupWitness"),
    ]

    fileprivate class _StorageClass {
        var _headBlockNum: Int64 = 0
        var _headBlockTimestamp: Int64 = 0
        var _headBlockHash: String = .init()
        var _forkCount: Int32 = 0
        var _failForkCount: Int32 = 0
        var _blockProcessTime: Protocol_MetricsInfo.RateInfo? = nil
        var _tps: Protocol_MetricsInfo.RateInfo? = nil
        var _transactionCacheSize: Int32 = 0
        var _missedTransaction: Protocol_MetricsInfo.RateInfo? = nil
        var _witnesses: [Protocol_MetricsInfo.BlockChainInfo.Witness] = []
        var _failProcessBlockNum: Int64 = 0
        var _failProcessBlockReason: String = .init()
        var _dupWitness: [Protocol_MetricsInfo.BlockChainInfo.DupWitness] = []

        static let defaultInstance = _StorageClass()

        private init() { }

        init(copying source: _StorageClass) {
            _headBlockNum = source._headBlockNum
            _headBlockTimestamp = source._headBlockTimestamp
            _headBlockHash = source._headBlockHash
            _forkCount = source._forkCount
            _failForkCount = source._failForkCount
            _blockProcessTime = source._blockProcessTime
            _tps = source._tps
            _transactionCacheSize = source._transactionCacheSize
            _missedTransaction = source._missedTransaction
            _witnesses = source._witnesses
            _failProcessBlockNum = source._failProcessBlockNum
            _failProcessBlockReason = source._failProcessBlockReason
            _dupWitness = source._dupWitness
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularInt64Field(value: &_storage._headBlockNum)
                case 2: try decoder.decodeSingularInt64Field(value: &_storage._headBlockTimestamp)
                case 3: try decoder.decodeSingularStringField(value: &_storage._headBlockHash)
                case 4: try decoder.decodeSingularInt32Field(value: &_storage._forkCount)
                case 5: try decoder.decodeSingularInt32Field(value: &_storage._failForkCount)
                case 6: try decoder.decodeSingularMessageField(value: &_storage._blockProcessTime)
                case 7: try decoder.decodeSingularMessageField(value: &_storage._tps)
                case 8: try decoder.decodeSingularInt32Field(value: &_storage._transactionCacheSize)
                case 9: try decoder.decodeSingularMessageField(value: &_storage._missedTransaction)
                case 10: try decoder.decodeRepeatedMessageField(value: &_storage._witnesses)
                case 11: try decoder.decodeSingularInt64Field(value: &_storage._failProcessBlockNum)
                case 12: try decoder.decodeSingularStringField(value: &_storage._failProcessBlockReason)
                case 13: try decoder.decodeRepeatedMessageField(value: &_storage._dupWitness)
                default: break
                }
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            if _storage._headBlockNum != 0 {
                try visitor.visitSingularInt64Field(value: _storage._headBlockNum, fieldNumber: 1)
            }
            if _storage._headBlockTimestamp != 0 {
                try visitor.visitSingularInt64Field(value: _storage._headBlockTimestamp, fieldNumber: 2)
            }
            if !_storage._headBlockHash.isEmpty {
                try visitor.visitSingularStringField(value: _storage._headBlockHash, fieldNumber: 3)
            }
            if _storage._forkCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._forkCount, fieldNumber: 4)
            }
            if _storage._failForkCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._failForkCount, fieldNumber: 5)
            }
            try { if let v = _storage._blockProcessTime {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
            } }()
            try { if let v = _storage._tps {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            } }()
            if _storage._transactionCacheSize != 0 {
                try visitor.visitSingularInt32Field(value: _storage._transactionCacheSize, fieldNumber: 8)
            }
            try { if let v = _storage._missedTransaction {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
            } }()
            if !_storage._witnesses.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._witnesses, fieldNumber: 10)
            }
            if _storage._failProcessBlockNum != 0 {
                try visitor.visitSingularInt64Field(value: _storage._failProcessBlockNum, fieldNumber: 11)
            }
            if !_storage._failProcessBlockReason.isEmpty {
                try visitor.visitSingularStringField(value: _storage._failProcessBlockReason, fieldNumber: 12)
            }
            if !_storage._dupWitness.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._dupWitness, fieldNumber: 13)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_MetricsInfo.BlockChainInfo, rhs: Protocol_MetricsInfo.BlockChainInfo) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((
                lhs._storage,
                rhs._storage
            )) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._headBlockNum != rhs_storage._headBlockNum { return false }
                if _storage._headBlockTimestamp != rhs_storage._headBlockTimestamp { return false }
                if _storage._headBlockHash != rhs_storage._headBlockHash { return false }
                if _storage._forkCount != rhs_storage._forkCount { return false }
                if _storage._failForkCount != rhs_storage._failForkCount { return false }
                if _storage._blockProcessTime != rhs_storage._blockProcessTime { return false }
                if _storage._tps != rhs_storage._tps { return false }
                if _storage._transactionCacheSize != rhs_storage._transactionCacheSize { return false }
                if _storage._missedTransaction != rhs_storage._missedTransaction { return false }
                if _storage._witnesses != rhs_storage._witnesses { return false }
                if _storage._failProcessBlockNum != rhs_storage._failProcessBlockNum { return false }
                if _storage._failProcessBlockReason != rhs_storage._failProcessBlockReason { return false }
                if _storage._dupWitness != rhs_storage._dupWitness { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MetricsInfo.BlockChainInfo.Witness + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MetricsInfo.BlockChainInfo.Witness: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_MetricsInfo.BlockChainInfo.protoMessageName + ".Witness"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "address"),
        2: .same(proto: "version"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &address)
            case 2: try decoder.decodeSingularInt32Field(value: &version)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !address.isEmpty {
            try visitor.visitSingularStringField(value: address, fieldNumber: 1)
        }
        if version != 0 {
            try visitor.visitSingularInt32Field(value: version, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_MetricsInfo.BlockChainInfo.Witness, rhs: Protocol_MetricsInfo.BlockChainInfo.Witness) -> Bool {
        if lhs.address != rhs.address { return false }
        if lhs.version != rhs.version { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MetricsInfo.BlockChainInfo.DupWitness + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MetricsInfo.BlockChainInfo.DupWitness: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_MetricsInfo.BlockChainInfo.protoMessageName + ".DupWitness"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "address"),
        2: .same(proto: "blockNum"),
        3: .same(proto: "count"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &address)
            case 2: try decoder.decodeSingularInt64Field(value: &blockNum)
            case 3: try decoder.decodeSingularInt32Field(value: &count)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !address.isEmpty {
            try visitor.visitSingularStringField(value: address, fieldNumber: 1)
        }
        if blockNum != 0 {
            try visitor.visitSingularInt64Field(value: blockNum, fieldNumber: 2)
        }
        if count != 0 {
            try visitor.visitSingularInt32Field(value: count, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Protocol_MetricsInfo.BlockChainInfo.DupWitness,
        rhs: Protocol_MetricsInfo.BlockChainInfo.DupWitness
    ) -> Bool {
        if lhs.address != rhs.address { return false }
        if lhs.blockNum != rhs.blockNum { return false }
        if lhs.count != rhs.count { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MetricsInfo.RateInfo + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MetricsInfo.RateInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_MetricsInfo.protoMessageName + ".RateInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "count"),
        2: .same(proto: "meanRate"),
        3: .same(proto: "oneMinuteRate"),
        4: .same(proto: "fiveMinuteRate"),
        5: .same(proto: "fifteenMinuteRate"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &count)
            case 2: try decoder.decodeSingularDoubleField(value: &meanRate)
            case 3: try decoder.decodeSingularDoubleField(value: &oneMinuteRate)
            case 4: try decoder.decodeSingularDoubleField(value: &fiveMinuteRate)
            case 5: try decoder.decodeSingularDoubleField(value: &fifteenMinuteRate)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if count != 0 {
            try visitor.visitSingularInt64Field(value: count, fieldNumber: 1)
        }
        if meanRate != 0 {
            try visitor.visitSingularDoubleField(value: meanRate, fieldNumber: 2)
        }
        if oneMinuteRate != 0 {
            try visitor.visitSingularDoubleField(value: oneMinuteRate, fieldNumber: 3)
        }
        if fiveMinuteRate != 0 {
            try visitor.visitSingularDoubleField(value: fiveMinuteRate, fieldNumber: 4)
        }
        if fifteenMinuteRate != 0 {
            try visitor.visitSingularDoubleField(value: fifteenMinuteRate, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_MetricsInfo.RateInfo, rhs: Protocol_MetricsInfo.RateInfo) -> Bool {
        if lhs.count != rhs.count { return false }
        if lhs.meanRate != rhs.meanRate { return false }
        if lhs.oneMinuteRate != rhs.oneMinuteRate { return false }
        if lhs.fiveMinuteRate != rhs.fiveMinuteRate { return false }
        if lhs.fifteenMinuteRate != rhs.fifteenMinuteRate { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MetricsInfo.NetInfo + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MetricsInfo.NetInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_MetricsInfo.protoMessageName + ".NetInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "errorProtoCount"),
        2: .same(proto: "api"),
        3: .same(proto: "connectionCount"),
        4: .same(proto: "validConnectionCount"),
        5: .same(proto: "tcpInTraffic"),
        6: .same(proto: "tcpOutTraffic"),
        7: .same(proto: "disconnectionCount"),
        8: .same(proto: "disconnectionDetail"),
        9: .same(proto: "udpInTraffic"),
        10: .same(proto: "udpOutTraffic"),
        11: .same(proto: "latency"),
    ]

    fileprivate class _StorageClass {
        var _errorProtoCount: Int32 = 0
        var _api: Protocol_MetricsInfo.NetInfo.ApiInfo? = nil
        var _connectionCount: Int32 = 0
        var _validConnectionCount: Int32 = 0
        var _tcpInTraffic: Protocol_MetricsInfo.RateInfo? = nil
        var _tcpOutTraffic: Protocol_MetricsInfo.RateInfo? = nil
        var _disconnectionCount: Int32 = 0
        var _disconnectionDetail: [Protocol_MetricsInfo.NetInfo.DisconnectionDetailInfo] = []
        var _udpInTraffic: Protocol_MetricsInfo.RateInfo? = nil
        var _udpOutTraffic: Protocol_MetricsInfo.RateInfo? = nil
        var _latency: Protocol_MetricsInfo.NetInfo.LatencyInfo? = nil

        static let defaultInstance = _StorageClass()

        private init() { }

        init(copying source: _StorageClass) {
            _errorProtoCount = source._errorProtoCount
            _api = source._api
            _connectionCount = source._connectionCount
            _validConnectionCount = source._validConnectionCount
            _tcpInTraffic = source._tcpInTraffic
            _tcpOutTraffic = source._tcpOutTraffic
            _disconnectionCount = source._disconnectionCount
            _disconnectionDetail = source._disconnectionDetail
            _udpInTraffic = source._udpInTraffic
            _udpOutTraffic = source._udpOutTraffic
            _latency = source._latency
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularInt32Field(value: &_storage._errorProtoCount)
                case 2: try decoder.decodeSingularMessageField(value: &_storage._api)
                case 3: try decoder.decodeSingularInt32Field(value: &_storage._connectionCount)
                case 4: try decoder.decodeSingularInt32Field(value: &_storage._validConnectionCount)
                case 5: try decoder.decodeSingularMessageField(value: &_storage._tcpInTraffic)
                case 6: try decoder.decodeSingularMessageField(value: &_storage._tcpOutTraffic)
                case 7: try decoder.decodeSingularInt32Field(value: &_storage._disconnectionCount)
                case 8: try decoder.decodeRepeatedMessageField(value: &_storage._disconnectionDetail)
                case 9: try decoder.decodeSingularMessageField(value: &_storage._udpInTraffic)
                case 10: try decoder.decodeSingularMessageField(value: &_storage._udpOutTraffic)
                case 11: try decoder.decodeSingularMessageField(value: &_storage._latency)
                default: break
                }
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            if _storage._errorProtoCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._errorProtoCount, fieldNumber: 1)
            }
            try { if let v = _storage._api {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            } }()
            if _storage._connectionCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._connectionCount, fieldNumber: 3)
            }
            if _storage._validConnectionCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._validConnectionCount, fieldNumber: 4)
            }
            try { if let v = _storage._tcpInTraffic {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            } }()
            try { if let v = _storage._tcpOutTraffic {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
            } }()
            if _storage._disconnectionCount != 0 {
                try visitor.visitSingularInt32Field(value: _storage._disconnectionCount, fieldNumber: 7)
            }
            if !_storage._disconnectionDetail.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._disconnectionDetail, fieldNumber: 8)
            }
            try { if let v = _storage._udpInTraffic {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
            } }()
            try { if let v = _storage._udpOutTraffic {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
            } }()
            try { if let v = _storage._latency {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
            } }()
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_MetricsInfo.NetInfo, rhs: Protocol_MetricsInfo.NetInfo) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((
                lhs._storage,
                rhs._storage
            )) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._errorProtoCount != rhs_storage._errorProtoCount { return false }
                if _storage._api != rhs_storage._api { return false }
                if _storage._connectionCount != rhs_storage._connectionCount { return false }
                if _storage._validConnectionCount != rhs_storage._validConnectionCount { return false }
                if _storage._tcpInTraffic != rhs_storage._tcpInTraffic { return false }
                if _storage._tcpOutTraffic != rhs_storage._tcpOutTraffic { return false }
                if _storage._disconnectionCount != rhs_storage._disconnectionCount { return false }
                if _storage._disconnectionDetail != rhs_storage._disconnectionDetail { return false }
                if _storage._udpInTraffic != rhs_storage._udpInTraffic { return false }
                if _storage._udpOutTraffic != rhs_storage._udpOutTraffic { return false }
                if _storage._latency != rhs_storage._latency { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MetricsInfo.NetInfo.ApiInfo + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MetricsInfo.NetInfo.ApiInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_MetricsInfo.NetInfo.protoMessageName + ".ApiInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "qps"),
        2: .same(proto: "failQps"),
        3: .same(proto: "outTraffic"),
        4: .same(proto: "detail"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_qps)
            case 2: try decoder.decodeSingularMessageField(value: &_failQps)
            case 3: try decoder.decodeSingularMessageField(value: &_outTraffic)
            case 4: try decoder.decodeRepeatedMessageField(value: &detail)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _qps {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try { if let v = self._failQps {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._outTraffic {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        if !detail.isEmpty {
            try visitor.visitRepeatedMessageField(value: detail, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_MetricsInfo.NetInfo.ApiInfo, rhs: Protocol_MetricsInfo.NetInfo.ApiInfo) -> Bool {
        if lhs._qps != rhs._qps { return false }
        if lhs._failQps != rhs._failQps { return false }
        if lhs._outTraffic != rhs._outTraffic { return false }
        if lhs.detail != rhs.detail { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_MetricsInfo.NetInfo.ApiInfo.protoMessageName + ".ApiDetailInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
        2: .same(proto: "qps"),
        3: .same(proto: "failQps"),
        4: .same(proto: "outTraffic"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularMessageField(value: &_qps)
            case 3: try decoder.decodeSingularMessageField(value: &_failQps)
            case 4: try decoder.decodeSingularMessageField(value: &_outTraffic)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try { if let v = self._qps {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._failQps {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._outTraffic {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Protocol_MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo,
        rhs: Protocol_MetricsInfo.NetInfo.ApiInfo.ApiDetailInfo
    ) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs._qps != rhs._qps { return false }
        if lhs._failQps != rhs._failQps { return false }
        if lhs._outTraffic != rhs._outTraffic { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MetricsInfo.NetInfo.DisconnectionDetailInfo + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MetricsInfo.NetInfo.DisconnectionDetailInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_MetricsInfo.NetInfo.protoMessageName + ".DisconnectionDetailInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "reason"),
        2: .same(proto: "count"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &reason)
            case 2: try decoder.decodeSingularInt32Field(value: &count)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !reason.isEmpty {
            try visitor.visitSingularStringField(value: reason, fieldNumber: 1)
        }
        if count != 0 {
            try visitor.visitSingularInt32Field(value: count, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Protocol_MetricsInfo.NetInfo.DisconnectionDetailInfo,
        rhs: Protocol_MetricsInfo.NetInfo.DisconnectionDetailInfo
    ) -> Bool {
        if lhs.reason != rhs.reason { return false }
        if lhs.count != rhs.count { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MetricsInfo.NetInfo.LatencyInfo + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MetricsInfo.NetInfo.LatencyInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_MetricsInfo.NetInfo.protoMessageName + ".LatencyInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "top99"),
        2: .same(proto: "top95"),
        3: .same(proto: "top75"),
        4: .same(proto: "totalCount"),
        5: .same(proto: "delay1S"),
        6: .same(proto: "delay2S"),
        7: .same(proto: "delay3S"),
        8: .same(proto: "detail"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt32Field(value: &top99)
            case 2: try decoder.decodeSingularInt32Field(value: &top95)
            case 3: try decoder.decodeSingularInt32Field(value: &top75)
            case 4: try decoder.decodeSingularInt32Field(value: &totalCount)
            case 5: try decoder.decodeSingularInt32Field(value: &delay1S)
            case 6: try decoder.decodeSingularInt32Field(value: &delay2S)
            case 7: try decoder.decodeSingularInt32Field(value: &delay3S)
            case 8: try decoder.decodeRepeatedMessageField(value: &detail)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if top99 != 0 {
            try visitor.visitSingularInt32Field(value: top99, fieldNumber: 1)
        }
        if top95 != 0 {
            try visitor.visitSingularInt32Field(value: top95, fieldNumber: 2)
        }
        if top75 != 0 {
            try visitor.visitSingularInt32Field(value: top75, fieldNumber: 3)
        }
        if totalCount != 0 {
            try visitor.visitSingularInt32Field(value: totalCount, fieldNumber: 4)
        }
        if delay1S != 0 {
            try visitor.visitSingularInt32Field(value: delay1S, fieldNumber: 5)
        }
        if delay2S != 0 {
            try visitor.visitSingularInt32Field(value: delay2S, fieldNumber: 6)
        }
        if delay3S != 0 {
            try visitor.visitSingularInt32Field(value: delay3S, fieldNumber: 7)
        }
        if !detail.isEmpty {
            try visitor.visitRepeatedMessageField(value: detail, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_MetricsInfo.NetInfo.LatencyInfo, rhs: Protocol_MetricsInfo.NetInfo.LatencyInfo) -> Bool {
        if lhs.top99 != rhs.top99 { return false }
        if lhs.top95 != rhs.top95 { return false }
        if lhs.top75 != rhs.top75 { return false }
        if lhs.totalCount != rhs.totalCount { return false }
        if lhs.delay1S != rhs.delay1S { return false }
        if lhs.delay2S != rhs.delay2S { return false }
        if lhs.delay3S != rhs.delay3S { return false }
        if lhs.detail != rhs.detail { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo: SwiftProtobuf.Message,
    SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_MetricsInfo.NetInfo.LatencyInfo.protoMessageName + ".LatencyDetailInfo"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "witness"),
        2: .same(proto: "top99"),
        3: .same(proto: "top95"),
        4: .same(proto: "top75"),
        5: .same(proto: "count"),
        6: .same(proto: "delay1S"),
        7: .same(proto: "delay2S"),
        8: .same(proto: "delay3S"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &witness)
            case 2: try decoder.decodeSingularInt32Field(value: &top99)
            case 3: try decoder.decodeSingularInt32Field(value: &top95)
            case 4: try decoder.decodeSingularInt32Field(value: &top75)
            case 5: try decoder.decodeSingularInt32Field(value: &count)
            case 6: try decoder.decodeSingularInt32Field(value: &delay1S)
            case 7: try decoder.decodeSingularInt32Field(value: &delay2S)
            case 8: try decoder.decodeSingularInt32Field(value: &delay3S)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !witness.isEmpty {
            try visitor.visitSingularStringField(value: witness, fieldNumber: 1)
        }
        if top99 != 0 {
            try visitor.visitSingularInt32Field(value: top99, fieldNumber: 2)
        }
        if top95 != 0 {
            try visitor.visitSingularInt32Field(value: top95, fieldNumber: 3)
        }
        if top75 != 0 {
            try visitor.visitSingularInt32Field(value: top75, fieldNumber: 4)
        }
        if count != 0 {
            try visitor.visitSingularInt32Field(value: count, fieldNumber: 5)
        }
        if delay1S != 0 {
            try visitor.visitSingularInt32Field(value: delay1S, fieldNumber: 6)
        }
        if delay2S != 0 {
            try visitor.visitSingularInt32Field(value: delay2S, fieldNumber: 7)
        }
        if delay3S != 0 {
            try visitor.visitSingularInt32Field(value: delay3S, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: Protocol_MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo,
        rhs: Protocol_MetricsInfo.NetInfo.LatencyInfo.LatencyDetailInfo
    ) -> Bool {
        if lhs.witness != rhs.witness { return false }
        if lhs.top99 != rhs.top99 { return false }
        if lhs.top95 != rhs.top95 { return false }
        if lhs.top75 != rhs.top75 { return false }
        if lhs.count != rhs.count { return false }
        if lhs.delay1S != rhs.delay1S { return false }
        if lhs.delay2S != rhs.delay2S { return false }
        if lhs.delay3S != rhs.delay3S { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_PBFTMessage + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_PBFTMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".PBFTMessage"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "raw_data"),
        2: .same(proto: "signature"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_rawData)
            case 2: try decoder.decodeSingularBytesField(value: &signature)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _rawData {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !signature.isEmpty {
            try visitor.visitSingularBytesField(value: signature, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_PBFTMessage, rhs: Protocol_PBFTMessage) -> Bool {
        if lhs._rawData != rhs._rawData { return false }
        if lhs.signature != rhs.signature { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_PBFTMessage.MsgType + SwiftProtobuf._ProtoNameProviding

extension Protocol_PBFTMessage.MsgType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "VIEW_CHANGE"),
        1: .same(proto: "REQUEST"),
        2: .same(proto: "PREPREPARE"),
        3: .same(proto: "PREPARE"),
        4: .same(proto: "COMMIT"),
    ]
}

// MARK: - Protocol_PBFTMessage.DataType + SwiftProtobuf._ProtoNameProviding

extension Protocol_PBFTMessage.DataType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "BLOCK"),
        1: .same(proto: "SRL"),
    ]
}

// MARK: - Protocol_PBFTMessage.Raw + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_PBFTMessage.Raw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = Protocol_PBFTMessage.protoMessageName + ".Raw"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "msg_type"),
        2: .standard(proto: "data_type"),
        3: .standard(proto: "view_n"),
        4: .same(proto: "epoch"),
        5: .same(proto: "data"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &msgType)
            case 2: try decoder.decodeSingularEnumField(value: &dataType)
            case 3: try decoder.decodeSingularInt64Field(value: &viewN)
            case 4: try decoder.decodeSingularInt64Field(value: &epoch)
            case 5: try decoder.decodeSingularBytesField(value: &data)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if msgType != .viewChange {
            try visitor.visitSingularEnumField(value: msgType, fieldNumber: 1)
        }
        if dataType != .block {
            try visitor.visitSingularEnumField(value: dataType, fieldNumber: 2)
        }
        if viewN != 0 {
            try visitor.visitSingularInt64Field(value: viewN, fieldNumber: 3)
        }
        if epoch != 0 {
            try visitor.visitSingularInt64Field(value: epoch, fieldNumber: 4)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_PBFTMessage.Raw, rhs: Protocol_PBFTMessage.Raw) -> Bool {
        if lhs.msgType != rhs.msgType { return false }
        if lhs.dataType != rhs.dataType { return false }
        if lhs.viewN != rhs.viewN { return false }
        if lhs.epoch != rhs.epoch { return false }
        if lhs.data != rhs.data { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_PBFTCommitResult + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_PBFTCommitResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".PBFTCommitResult"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "data"),
        2: .same(proto: "signature"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &data)
            case 2: try decoder.decodeRepeatedBytesField(value: &signature)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 1)
        }
        if !signature.isEmpty {
            try visitor.visitRepeatedBytesField(value: signature, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_PBFTCommitResult, rhs: Protocol_PBFTCommitResult) -> Bool {
        if lhs.data != rhs.data { return false }
        if lhs.signature != rhs.signature { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

// MARK: - Protocol_SRL + SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding

extension Protocol_SRL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SRL"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "srAddress"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedBytesField(value: &srAddress)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !srAddress.isEmpty {
            try visitor.visitRepeatedBytesField(value: srAddress, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_SRL, rhs: Protocol_SRL) -> Bool {
        if lhs.srAddress != rhs.srAddress { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
